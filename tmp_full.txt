#!/usr/bin/env python3
"""
Only-Test å¹¿å‘Šè‡ªåŠ¨å…³é—­åŠŸèƒ½æµ‹è¯•è„šæœ¬
========================================

ä¸“é—¨ç”¨äºæµ‹è¯•only_testçš„å¹¿å‘Šè‡ªåŠ¨æ£€æµ‹å’Œå…³é—­åŠŸèƒ½
æ”¯æŒä¸¤ç§æ¨¡å¼ï¼šbasic(å•æ¬¡æ£€æµ‹)å’Œcontinuous(è¿ç»­ç›‘æ§)
"""

import asyncio
import logging
import argparse
import sys
from pathlib import Path
from datetime import datetime

# æ·»åŠ é¡¹ç›®è·¯å¾„
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from lib.mcp_interface.device_inspector import DeviceInspector
from lib.visual_recognition.visual_integration import get_visual_integration, IntegrationConfig
from lib.visual_recognition.element_recognizer import ElementRecognizer
from lib.screen_capture import ScreenCapture

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Ensure custom Poco (uiautomator2-based) is on sys.path and import it
# project_root æŒ‡å‘ only_test ç›®å½•ï¼Œæ­¤å¤„éœ€è¦ä¸Šæº¯åˆ°ä»“åº“æ ¹ç›®å½•å†è¿›å…¥ Poco/
repo_root = project_root.parent
poco_root = repo_root / "Poco"
if str(poco_root) not in sys.path:
    sys.path.insert(0, str(poco_root))
try:
    from poco.drivers.android.uiautomator2 import AndroidUiautomator2Poco
except Exception as _e:
    AndroidUiautomator2Poco = None
    logger.error(f"æ— æ³•å¯¼å…¥ AndroidUiautomator2Poco: {_e}")


async def test_ad_closer_basic(device_id: str = None, target_app: str = "com.mobile.brasiltvmobile"):
    """åŸºç¡€å¹¿å‘Šå…³é—­æµ‹è¯•"""
    print("\n" + "="*60)
    print("ğŸ¯ Only-Test å¹¿å‘Šè‡ªåŠ¨å…³é—­åŠŸèƒ½æµ‹è¯•")
    print("="*60)
    
    # åˆå§‹åŒ–è®¾å¤‡æ£€æŸ¥å™¨
    inspector = DeviceInspector(device_id=device_id)
    
    print(f"ğŸ“± å¯åŠ¨åº”ç”¨: {target_app}, æµ‹è¯•æ¨¡å¼è¯·ç¡®ä¿æŒ‡å®š APK å·²å¯åŠ¨, ä¸å†è‡ªåŠ¨å¯åŠ¨")
    print("\nğŸ” å¼€å§‹å¹¿å‘Šæ£€æµ‹å’Œè‡ªåŠ¨å…³é—­æµ‹è¯•...")
    
    try:
        # è·å–å½“å‰ç•Œé¢ä¿¡æ¯å¹¶è‡ªåŠ¨å¤„ç†å¹¿å‘Š
        result = await inspector.get_device_info()
        
        # è§£æç»“æœ
        ads_info = result.get("auto_close_attempts", 0) if result else 0
        confidence = result.get("confidence", 0) if result else 0
        auto_closed = result.get("auto_closed", False) if result else False
        
        print(f"\nğŸ“Š æ£€æµ‹ç»“æœ:")
        print(f"   å¹¿å‘Šæ£€æµ‹ç½®ä¿¡åº¦: {confidence:.2f}")
        print(f"   è‡ªåŠ¨å…³é—­å°è¯•æ¬¡æ•°: {ads_info}")
        print(f"   æ˜¯å¦æˆåŠŸå…³é—­: {'âœ… æ˜¯' if auto_closed else 'âŒ å¦'}")
        
        # æ˜¾ç¤ºå¹¿å‘Šå…ƒç´ è¯¦æƒ…ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        if confidence > 0.5:
            elements = result.get("elements", [])
            ad_elements = []
            close_elements = []
            
            for elem in elements:
                text = (elem.get('text') or '').lower()
                rid = (elem.get('resource_id') or '').lower()
                
                # æ£€æŸ¥å¹¿å‘Šç›¸å…³å…ƒç´ 
                if any(k in text or k in rid for k in ['ad', 'ads', 'å¹¿å‘Š']):
                    ad_elements.append(elem)
                
                # æ£€æŸ¥å…³é—­æŒ‰é’®å…ƒç´ 
                if any(k in text or k in rid for k in ['close', 'å…³é—­', 'skip', 'è·³è¿‡', 'ivclose', 'mivclose']):
                    close_elements.append(elem)
            
            if ad_elements:
                print(f"\nğŸ¯ æ£€æµ‹åˆ°å¹¿å‘Šå…ƒç´  ({len(ad_elements)} ä¸ª):")
                for elem in ad_elements[:3]:  # åªæ˜¾ç¤ºå‰3ä¸ª
                    if elem.get('text'):
                        print(f"       æ–‡æœ¬: {elem['text']}")
                    if elem.get('resource_id'):
                        print(f"       ID: {elem['resource_id']}")
                    if elem.get('clickable'):
                        print(f"       å¯ç‚¹å‡»: âœ…")
                    print()
            
            if close_elements:
                print(f"\nğŸ”˜ æ£€æµ‹åˆ°å…³é—­æŒ‰é’® ({len(close_elements)} ä¸ª):")
                for elem in close_elements[:3]:  # åªæ˜¾ç¤ºå‰3ä¸ª
                    if elem.get('text'):
                        print(f"       æ–‡æœ¬: {elem['text']}")
                    if elem.get('resource_id'):
                        print(f"       ID: {elem['resource_id']}")
                    if elem.get('clickable'):
                        print(f"       å¯ç‚¹å‡»: âœ…")
                    print()
        
        return result
        
    except Exception as e:
        logger.error(f"å¹¿å‘Šå…³é—­æµ‹è¯•å¤±è´¥: {e}")
        return None


async def test_ad_closer_continuous(device_id: str = None, target_app: str = "com.mobile.brasiltvmobile"):
    """è¿ç»­ç›‘æ§å¹¿å‘Šå…³é—­æµ‹è¯• - æŒç»­æ£€æµ‹å¹¶å…³é—­å¹¿å‘Š"""
    print("\n" + "="*60)
    print("ğŸ¯ è¿ç»­ç›‘æ§å¹¿å‘Šå…³é—­åŠŸèƒ½æµ‹è¯•")
    print("="*60)
    print(f"ğŸ“± ç›®æ ‡åº”ç”¨: {target_app}")
    print(f"ğŸ“± è®¾å¤‡ID: {device_id or 'Default'}")
    
    # åˆå§‹åŒ–è®¾å¤‡æ£€æŸ¥å™¨
    inspector = DeviceInspector(device_id=device_id)
    
    print("\nğŸ”„ å¼€å§‹è¿ç»­ç›‘æ§æ¨¡å¼...")
    print("âš ï¸  æŒ‰ Ctrl+C é€€å‡ºç›‘æ§")
    
    monitor_count = 0
    success_count = 0
    
    try:
        while True:
            monitor_count += 1
            print(f"\nğŸ“Š ç¬¬ {monitor_count} è½®æ£€æµ‹...")
            
            # è·å–å½“å‰ç•Œé¢ä¿¡æ¯å¹¶è‡ªåŠ¨å¤„ç†å¹¿å‘Š
            result = await inspector.get_device_info()
            
            # è§£æç»“æœ
            if result and result.get("auto_closed"):
                success_count += 1
                print(f"âœ… ç¬¬ {monitor_count} è½®: æˆåŠŸå…³é—­å¹¿å‘Š (æ€»æˆåŠŸ: {success_count})")
                print(f"   ç½®ä¿¡åº¦: {result.get('confidence', 0):.2f}")
                print(f"   å°è¯•æ¬¡æ•°: {result.get('auto_close_attempts', 0)}")
            else:
                confidence = result.get('confidence', 0) if result else 0
                print(f"ğŸ“Š ç¬¬ {monitor_count} è½®: æœªæ£€æµ‹åˆ°å¹¿å‘Š (ç½®ä¿¡åº¦: {confidence:.2f})")
            
            # ç­‰å¾…0.1ç§’åç»§ç»­ä¸‹ä¸€è½®æ£€æµ‹
            await asyncio.sleep(0.1)
            
    except KeyboardInterrupt:
        print(f"\n\nğŸ ç›‘æ§ç»“æŸ")
        print(f"ğŸ“Š ç»Ÿè®¡ç»“æœ:")
        print(f"   æ€»æ£€æµ‹è½®æ•°: {monitor_count}")
        print(f"   æˆåŠŸå…³é—­æ¬¡æ•°: {success_count}")
        print(f"   æ£€æµ‹æˆåŠŸç‡: {success_count/monitor_count*100:.1f}%" if monitor_count > 0 else "   æ£€æµ‹æˆåŠŸç‡: 0%")
        
        return {
            "total_rounds": monitor_count,
            "success_count": success_count,
            "success_rate": success_count/monitor_count if monitor_count > 0 else 0
        }


async def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(description="Only-Test å¹¿å‘Šè‡ªåŠ¨å…³é—­åŠŸèƒ½æµ‹è¯•å·¥å…·")
    parser.add_argument("--device-id", default=None, help="ADBè®¾å¤‡ID (å¯é€‰)")
    parser.add_argument("--target-app", default="com.mobile.brasiltvmobile", help="ç›®æ ‡åº”ç”¨åŒ…å")
    parser.add_argument("--mode", choices=["basic", "continuous"], 
                       default="basic", help="æµ‹è¯•æ¨¡å¼: basic=å•æ¬¡æ£€æµ‹, continuous=è¿ç»­ç›‘æ§")
    
    args = parser.parse_args()
    
    print(f"\nğŸš€ å¯åŠ¨ Only-Test å¹¿å‘Šå…³é—­æµ‹è¯•")
    print(f"ğŸ“± è®¾å¤‡: {args.device_id or 'Default'}")
    print(f"ğŸ“¦ åº”ç”¨: {args.target_app}")
    print(f"ğŸ¯ æ¨¡å¼: {args.mode}")
    
    try:
        if args.mode == "basic":
            await test_ad_closer_basic(args.device_id, args.target_app)
        elif args.mode == "continuous":
            await test_ad_closer_continuous(args.device_id, args.target_app)
            
    except KeyboardInterrupt:
        print("\n\nâš ï¸  æµ‹è¯•è¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        logger.error(f"æµ‹è¯•æ‰§è¡Œå¤±è´¥: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main())

