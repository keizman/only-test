# ğŸ¯ Only-Test è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶

**Write Once, Test Everywhere** - ä»…å†™ä¸€æ¬¡æµ‹è¯•ï¼Œéšå¤„å¯ç”¨çš„æ™ºèƒ½åŒ– APK è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Python](https://img.shields.io/badge/python-3.8+-brightgreen.svg)](https://python.org)
[![Status](https://img.shields.io/badge/status-active-success.svg)](README.md)

---

## ğŸ“– ç›®å½•

- [ğŸ¯ Only-Test è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶](#-only-test-è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [ğŸš€ é¡¹ç›®æ„¿æ™¯](#-é¡¹ç›®æ„¿æ™¯)
  - [ğŸ’¡ æ ¸å¿ƒç†å¿µ](#-æ ¸å¿ƒç†å¿µ)
  - [ğŸ—ï¸ æ¡†æ¶æ¶æ„](#ï¸-æ¡†æ¶æ¶æ„)
  - [ğŸ”§ æ ¸å¿ƒç»„ä»¶](#-æ ¸å¿ƒç»„ä»¶)
  - [ğŸ® æµ‹è¯•åœºæ™¯](#-æµ‹è¯•åœºæ™¯)
  - [ğŸ“‹ ç”¨ä¾‹å…ƒæ•°æ®è§„èŒƒ](#-ç”¨ä¾‹å…ƒæ•°æ®è§„èŒƒ)
  - [ğŸ¤– æ™ºèƒ½ç”¨ä¾‹ç”Ÿæˆ](#-æ™ºèƒ½ç”¨ä¾‹ç”Ÿæˆ)
  - [ğŸ” å…ƒç´ è¯†åˆ«ç­–ç•¥](#-å…ƒç´ è¯†åˆ«ç­–ç•¥)
  - [âš¡ å¼‚å¸¸æ¢å¤æœºåˆ¶](#-å¼‚å¸¸æ¢å¤æœºåˆ¶)
  - [ğŸ“Š æ–­è¨€ä¸éªŒè¯](#-æ–­è¨€ä¸éªŒè¯)
  - [ğŸ“± å‰ç½®æ¡ä»¶ä¼˜åŒ–](#-å‰ç½®æ¡ä»¶ä¼˜åŒ–)
  - [ğŸ”„ ç”¨ä¾‹æ‰§è¡Œæµç¨‹](#-ç”¨ä¾‹æ‰§è¡Œæµç¨‹)
  - [ğŸ“ˆ ç›‘æ§ä¸æŠ¥å‘Š](#-ç›‘æ§ä¸æŠ¥å‘Š)
  - [ğŸ› ï¸ å¼€å‘å·¥å…·é“¾](#ï¸-å¼€å‘å·¥å…·é“¾)
  - [ğŸš€ å¿«é€Ÿå¼€å§‹](#-å¿«é€Ÿå¼€å§‹)
  - [ğŸ“š æŠ€æœ¯å®ç°](#-æŠ€æœ¯å®ç°)
  - [ğŸ¯ ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”](#-ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”)
  - [ğŸ”® æœªæ¥è§„åˆ’](#-æœªæ¥è§„åˆ’)
  - [ğŸ“– å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)

---

## ğŸš€ é¡¹ç›®æ„¿æ™¯

### ğŸ¯ **æ ¸å¿ƒç›®æ ‡**
æ„å»ºä¸€ä¸ª**ä¸€æ¬¡ç¼–å†™ï¼Œå¤„å¤„è¿è¡Œ**çš„æ™ºèƒ½åŒ– APK è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶ï¼Œè§£å†³ä¼ ç»Ÿ UI è‡ªåŠ¨åŒ–æµ‹è¯•çš„æ ¹æœ¬ç—›ç‚¹ï¼š

- **è·¨ APK å¤ç”¨**ï¼šåŒä¸€å¥—æµ‹è¯•ç”¨ä¾‹é€‚é…ä¸åŒç‰ˆæœ¬çš„ APK
- **è·¨è®¾å¤‡å…¼å®¹**ï¼šæ— ç¼æ”¯æŒ TVã€æ‰‹æœºã€å¹³æ¿å¤šç§è®¾å¤‡å½¢æ€  
- **æ™ºèƒ½ç”Ÿæˆ**ï¼šåŸºäº LLM è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ï¼Œä½†ä¿æŒæ‰§è¡Œæ—¶çš„ç¡®å®šæ€§
- **ä¸“ä¸šåŒ–å®šåˆ¶**ï¼šä¸“é—¨é’ˆå¯¹å½±è§†ç±» APP çš„æ’­æ”¾ã€äº’åŠ¨åœºæ™¯ä¼˜åŒ–

### ğŸŒŸ **è§£å†³çš„æ ¸å¿ƒé—®é¢˜**
```
ä¼ ç»Ÿé—®é¢˜ï¼š
âŒ æ¯ä¸ª APK éƒ½éœ€è¦å•ç‹¬å†™æµ‹è¯•ç”¨ä¾‹
âŒ å…ƒç´  ID å˜åŒ–å¯¼è‡´ç”¨ä¾‹å¤±æ•ˆ
âŒ æ— æ³•è·¨è®¾å¤‡è¿è¡Œ
âŒ æ’­æ”¾çŠ¶æ€ä¸‹æ— æ³•è·å– UI æ§ä»¶
âŒ TV ç«¯ DRM ä¿æŠ¤å¯¼è‡´æˆªå›¾å¤±è´¥
âŒ ç»´æŠ¤æˆæœ¬é«˜ï¼Œç¨³å®šæ€§å·®

Only-Test è§£å†³æ–¹æ¡ˆï¼š
âœ… ä¸€å¥—ç”¨ä¾‹é€‚é…æ‰€æœ‰ APK ç‰ˆæœ¬
âœ… æ™ºèƒ½å…ƒç´ è¯†åˆ«ä¸å®šä½
âœ… ç»Ÿä¸€çš„è®¾å¤‡æŠ½è±¡å±‚
âœ… ä¸“é—¨çš„æ’­æ”¾çŠ¶æ€å¤„ç†
âœ… ç™½ç›’æµ‹è¯•ç»•è¿‡ DRM é™åˆ¶
âœ… LLM é©±åŠ¨çš„æ™ºèƒ½åŒ–ç”Ÿæˆ
```

---

## ğŸ’¡ æ ¸å¿ƒç†å¿µ

### ğŸ§  **AI ç”Ÿæˆ + ç¡®å®šæ€§æ‰§è¡Œ**
```
è®¾è®¡å“²å­¦ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   LLM æ™ºèƒ½ç”Ÿæˆ   â”‚â”€â”€â”€â–¶â”‚   ç”¨ä¾‹æ ‡å‡†åŒ–     â”‚â”€â”€â”€â–¶â”‚   ç¡®å®šæ€§æ‰§è¡Œ     â”‚
â”‚                â”‚    â”‚                â”‚    â”‚                â”‚
â”‚ â€¢ è‡ªç„¶è¯­è¨€ç†è§£   â”‚    â”‚ â€¢ å…ƒæ•°æ®è§„èŒƒ     â”‚    â”‚ â€¢ å›ºå®šä»£ç æ‰§è¡Œ   â”‚
â”‚ â€¢ åœºæ™¯åˆ†æ      â”‚    â”‚ â€¢ æ ‡å‡†åŒ–æ ¼å¼     â”‚    â”‚ â€¢ é«˜ç¨³å®šæ€§      â”‚
â”‚ â€¢ è‡ªåŠ¨åŒ–ç¼–æ’    â”‚    â”‚ â€¢ ç»“æ„åŒ–å­˜å‚¨     â”‚    â”‚ â€¢ å¯é æ–­è¨€      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     ğŸ¤– æ™ºèƒ½           âš™ï¸ æ ‡å‡†åŒ–           ğŸ¯ æ‰§è¡Œ
```

### ğŸ“ **åˆ†å±‚æ¶æ„è®¾è®¡**
```
åº”ç”¨å±‚ (Application Layer)
â”œâ”€â”€ ç”¨ä¾‹ç”Ÿæˆå™¨ (Test Case Generator)
â”œâ”€â”€ æ‰§è¡Œå¼•æ“ (Execution Engine)  
â””â”€â”€ æŠ¥å‘Šç³»ç»Ÿ (Report System)

æŠ½è±¡å±‚ (Abstraction Layer)
â”œâ”€â”€ è®¾å¤‡æŠ½è±¡ (Device Abstraction)
â”œâ”€â”€ å…ƒç´ æŠ½è±¡ (Element Abstraction)
â””â”€â”€ åŠ¨ä½œæŠ½è±¡ (Action Abstraction)

è¯†åˆ«å±‚ (Recognition Layer)  
â”œâ”€â”€ XML å…ƒç´ å®šä½ (UIAutomator2)
â”œâ”€â”€ è§†è§‰è¯†åˆ« (Omniparser + YOLO)
â””â”€â”€ ç™½ç›’è®¿é—® (SDK Integration)

è®¾å¤‡å±‚ (Device Layer)
â”œâ”€â”€ Android æ‰‹æœº/å¹³æ¿
â”œâ”€â”€ Android TV/ç›’å­
â””â”€â”€ æ¨¡æ‹Ÿå™¨/äº‘è®¾å¤‡
```

---

## ğŸ—ï¸ æ¡†æ¶æ¶æ„

### ğŸ¯ **æ•´ä½“æ¶æ„å›¾**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          Only-Test æ¡†æ¶                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        ğŸ¤– LLM ç”¨ä¾‹ç”Ÿæˆå±‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ åœºæ™¯ç†è§£     â”‚  â”‚ ç”¨ä¾‹ç”Ÿæˆ     â”‚  â”‚ å…ƒæ•°æ®æ ‡å‡†åŒ– â”‚  â”‚ ä»£ç è¾“å‡º     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        âš™ï¸ æ‰§è¡Œå¼•æ“å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ è·¯å¾„è§„åˆ’     â”‚  â”‚ åŠ¨ä½œæ‰§è¡Œ     â”‚  â”‚ å¼‚å¸¸æ¢å¤     â”‚  â”‚ ç»“æœæ–­è¨€     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        ğŸ” æ™ºèƒ½è¯†åˆ«å±‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚UIAutomator2 â”‚  â”‚ Omniparser  â”‚  â”‚   YOLO      â”‚  â”‚  SDKé›†æˆ     â”‚ â”‚
â”‚  â”‚  (XMLå®šä½)   â”‚  â”‚  (è§†è§‰è¯†åˆ«)  â”‚  â”‚  (å›¾æ ‡è¯†åˆ«)  â”‚  â”‚  (ç™½ç›’æµ‹è¯•)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        ğŸ“± è®¾å¤‡æŠ½è±¡å±‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   æ‰‹æœº      â”‚  â”‚    å¹³æ¿      â”‚  â”‚   TV/ç›’å­    â”‚  â”‚   äº‘è®¾å¤‡     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”— **æ•°æ®æµå‘**
```
ç”¨ä¾‹æè¿° â†’ LLMè§£æ â†’ å…ƒæ•°æ®ç”Ÿæˆ â†’ æ‰§è¡Œè®¡åˆ’ â†’ è®¾å¤‡æ“ä½œ â†’ ç»“æœéªŒè¯ â†’ æŠ¥å‘Šè¾“å‡º
    â†“         â†“         â†“         â†“         â†“         â†“         â†“
è‡ªç„¶è¯­è¨€   ç»“æ„åŒ–     æ ‡å‡†æ ¼å¼   åŠ¨ä½œåºåˆ—   çœŸå®æ“ä½œ   æ–­è¨€æ£€æŸ¥   æµ‹è¯•æŠ¥å‘Š
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶

### 1. ğŸ¤– **LLM ç”¨ä¾‹ç”Ÿæˆå¼•æ“** 
```python
class TestCaseGenerator:
    """åŸºäº LLM çš„æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆå™¨"""
    
    def generate_from_description(self, description: str) -> TestCase:
        """ä»è‡ªç„¶è¯­è¨€æè¿°ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹"""
        
    def generate_from_scenario(self, scenario: TestScenario) -> List[TestCase]:
        """ä»æµ‹è¯•åœºæ™¯ç”Ÿæˆç”¨ä¾‹é›†åˆ"""
        
    def optimize_for_device(self, testcase: TestCase, device_type: str) -> TestCase:
        """ä¸ºç‰¹å®šè®¾å¤‡ä¼˜åŒ–æµ‹è¯•ç”¨ä¾‹"""
```

### 2. âš¡ **æ™ºèƒ½æ‰§è¡Œå¼•æ“**
```python
class ExecutionEngine:
    """æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œå¼•æ“"""
    
    def execute_testcase(self, testcase: TestCase, device: Device) -> TestResult:
        """æ‰§è¡Œå•ä¸ªæµ‹è¯•ç”¨ä¾‹"""
        
    def execute_suite(self, suite: TestSuite, device_pool: List[Device]) -> SuiteResult:
        """æ‰§è¡Œæµ‹è¯•å¥—ä»¶"""
        
    def recover_from_exception(self, exception: Exception, context: ExecutionContext):
        """å¼‚å¸¸æ¢å¤å¤„ç†"""
```

### 3. ğŸ” **å¤šæ¨¡å¼å…ƒç´ è¯†åˆ«å™¨**
```python
class ElementRecognizer:
    """ç»Ÿä¸€çš„å…ƒç´ è¯†åˆ«æ¥å£"""
    
    def find_element(self, selector: ElementSelector) -> Element:
        """ç»Ÿä¸€å…ƒç´ æŸ¥æ‰¾æ¥å£"""
        
    def find_elements(self, selector: ElementSelector) -> List[Element]:
        """æ‰¹é‡å…ƒç´ æŸ¥æ‰¾"""
        
    def switch_recognition_mode(self, mode: RecognitionMode):
        """åˆ‡æ¢è¯†åˆ«æ¨¡å¼"""

class RecognitionModes:
    XML_BASED = "xml"           # UIAutomator2 XML è§£æ
    VISUAL_BASED = "visual"     # Omniparser è§†è§‰è¯†åˆ«  
    HYBRID = "hybrid"           # æ··åˆæ¨¡å¼
    SDK_BASED = "sdk"           # SDK ç™½ç›’è®¿é—®
```

### 4. ğŸ¯ **è®¾å¤‡æŠ½è±¡å±‚**
```python
class Device:
    """ç»Ÿä¸€è®¾å¤‡æ¥å£"""
    
    def tap(self, x: int, y: int):
        """ç‚¹å‡»æ“ä½œ"""
        
    def swipe(self, start: Point, end: Point, duration: int):
        """æ»‘åŠ¨æ“ä½œ"""
        
    def input_text(self, text: str):
        """æ–‡æœ¬è¾“å…¥"""
        
    def take_screenshot(self) -> Image:
        """æˆªå›¾"""
        
    def get_current_activity(self) -> str:
        """è·å–å½“å‰é¡µé¢"""

class DeviceTypes:
    ANDROID_PHONE = "android_phone"
    ANDROID_TABLET = "android_tablet"
    ANDROID_TV = "android_tv"
    EMULATOR = "emulator"
```

---

## ğŸ® æµ‹è¯•åœºæ™¯

### ğŸ“º **å½±è§†ç±» APP æ ¸å¿ƒåœºæ™¯**

#### 1. **åª’èµ„æ’­æ”¾æµ‹è¯•**
```yaml
åœºæ™¯: å¤šæ ¼å¼åª’èµ„å…¼å®¹æ€§æµ‹è¯•
æ ‡ç­¾: [vod, playing, compatibility]
æµ‹è¯•ç‚¹:
  - è§†é¢‘æ ¼å¼: fmp4, mp4(H264), mp4(H265), ts, hls
  - éŸ³é¢‘æ ¼å¼: aac, mp3, ac3
  - åˆ†è¾¨ç‡: 720p, 1080p, 4K, 8K
  - ç¼–ç : H.264, H.265, AV1
```

#### 2. **æ’­æ”¾å™¨åŠŸèƒ½æµ‹è¯•**  
```yaml
åœºæ™¯: æ’­æ”¾å™¨äº¤äº’åŠŸèƒ½
æ ‡ç­¾: [playing, interaction]
æµ‹è¯•ç‚¹:
  - æ’­æ”¾æ§åˆ¶: æ’­æ”¾/æš‚åœ, å¿«è¿›/å¿«é€€, è·³è½¬
  - æ‹–åŠ¨è¿›åº¦: è¿›åº¦æ¡æ‹–åŠ¨, æ—¶é—´è·³è½¬
  - éŸ³è½¨åˆ‡æ¢: å¤šéŸ³è½¨é€‰æ‹©, éŸ³é‡æ§åˆ¶
  - æ¸…æ™°åº¦åˆ‡æ¢: è‡ªåŠ¨/æ‰‹åŠ¨åˆ‡æ¢ä¸åŒåˆ†è¾¨ç‡
  - æ’­æ”¾å™¨åˆ‡æ¢: å¤šæ’­æ”¾å™¨å¼•æ“åˆ‡æ¢
```

#### 3. **è·¨é¡µé¢å¯¼èˆªæµ‹è¯•**
```yaml
åœºæ™¯: ç”¨æˆ·æ“ä½œè·¯å¾„
æ ‡ç­¾: [navigation, search, vod]
æµ‹è¯•è·¯å¾„:
  é¦–é¡µ â†’ æœç´¢ â†’ è¾“å…¥èŠ‚ç›®å â†’ æœç´¢ç»“æœ â†’ èŠ‚ç›®è¯¦æƒ… â†’ æ’­æ”¾é¡µ
  é¦–é¡µ â†’ æ ç›®æµè§ˆ â†’ èŠ‚ç›®åˆ—è¡¨ â†’ èŠ‚ç›®è¯¦æƒ… â†’ æ’­æ”¾é¡µ  
  æ’­æ”¾é¡µ â†’ ç›¸å…³æ¨è â†’ å…¶ä»–èŠ‚ç›® â†’ æ’­æ”¾é¡µ
```

#### 4. **ç³»ç»Ÿé›†æˆæµ‹è¯•**
```yaml
åœºæ™¯: ç³»ç»Ÿçº§åŠŸèƒ½
æ ‡ç­¾: [system, integration]
æµ‹è¯•ç‚¹:
  - ç½‘ç»œå¼‚å¸¸å¤„ç†: æ–­ç½‘æ¢å¤, ç½‘ç»œåˆ‡æ¢
  - å†…å­˜ç®¡ç†: å†…å­˜ä¸è¶³å¤„ç†, åå°åˆ‡æ¢
  - æƒé™ç®¡ç†: å­˜å‚¨æƒé™, ç½‘ç»œæƒé™
  - æ¨é€å¤„ç†: é€šçŸ¥æ æ¨é€, åº”ç”¨å†…æ¨é€
```

---

## ğŸ“‹ æ™ºèƒ½å…ƒæ•°æ®ä½“ç³»è®¾è®¡

### ğŸ’¡ **å…ƒæ•°æ®è®¾è®¡å“²å­¦**

#### ğŸ¯ **æ ¸å¿ƒè®¾è®¡åŸåˆ™**
```
ä¼ ç»Ÿæµ‹è¯•ç”¨ä¾‹ï¼šæè¿° "åšä»€ä¹ˆ"
Only-Test ç”¨ä¾‹ï¼šæè¿° "ä¸ºä»€ä¹ˆè¿™æ ·åš" + "å¦‚ä½•æ™ºèƒ½åˆ¤æ–­"

ç¤ºä¾‹å¯¹æ¯”:
âŒ ä¼ ç»Ÿ: click(search_button)
âœ… Only-Test: æ ¹æ®æœç´¢æ¡†å†…å®¹çŠ¶æ€ï¼Œæ™ºèƒ½é€‰æ‹©ç‚¹å‡»æœç´¢æˆ–å–æ¶ˆæŒ‰é’®
```

#### ğŸ§  **æ™ºèƒ½åŒ–å…ƒæ•°æ®çš„å¿…è¦æ€§**
ä½ çš„ä¾‹å­ `page: search page, comment: click search button-either cancel search button, judge by box have content or not` å®Œç¾å±•ç¤ºäº†ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½å…ƒæ•°æ®ï¼š

1. **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**: `page: search page` - LLM çŸ¥é“å½“å‰åœ¨æœç´¢é¡µ
2. **æ¡ä»¶åˆ¤æ–­**: `judge by box have content or not` - åŒ…å«åˆ¤æ–­é€»è¾‘
3. **å¤šè·¯å¾„é€‰æ‹©**: `either cancel search button` - æ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒæ“ä½œ
4. **ä¸šåŠ¡è¯­ä¹‰**: LLM ä¸€çœ¼å°±èƒ½ç†è§£æ“ä½œæ„å›¾

### ğŸ·ï¸ **Only-Test æ™ºèƒ½å…ƒæ•°æ®æ ¼å¼**
```json
{
  "testcase_id": "TC_SEARCH_SMART_001",
  "name": "æ™ºèƒ½æœç´¢æ“ä½œæµ‹è¯•",
  "version": "2.0.0",
  "metadata": {
    "tags": ["search", "smart_judgment", "conditional"],
    "priority": "high",
    "estimated_duration": 60,
    "device_types": ["android_phone", "android_tv"],
    "app_versions": [">=3.0.0"],
    "complexity": "conditional_logic",
    "ai_friendly": true
  },
  "context_awareness": {
    "current_app_state": "launched",
    "expected_page": "search_page", 
    "user_session": "anonymous",
    "network_status": "connected"
  },
  "execution_path": [
    {
      "step": 1,
      "page": "home",
      "action": "click",
      "target": "search_button",
      "description": "ç‚¹å‡»é¦–é¡µæœç´¢æŒ‰é’®",
      "success_criteria": "è¿›å…¥æœç´¢é¡µé¢",
      "ai_hint": "å¯»æ‰¾æœç´¢å›¾æ ‡æˆ–æœç´¢æ–‡å­—"
    },
    {
      "step": 2,
      "page": "search_page",
      "action": "conditional_action",
      "condition": {
        "type": "element_content_check",
        "target": "search_input_box",
        "check": "has_text_content"
      },
      "conditional_paths": {
        "if_has_content": {
          "action": "click",
          "target": "cancel_button", 
          "reason": "æ¸…ç©ºå·²æœ‰æœç´¢å†…å®¹",
          "ai_hint": "å¯»æ‰¾å–æ¶ˆã€æ¸…ç©ºã€Xç­‰æŒ‰é’®"
        },
        "if_empty": {
          "action": "input",
          "target": "search_input_box",
          "data": "${test_program_name}",
          "reason": "è¾“å…¥æœç´¢å…³é”®è¯",
          "ai_hint": "å¯»æ‰¾è¾“å…¥æ¡†å¹¶è¾“å…¥å†…å®¹"
        }
      },
      "description": "æ ¹æ®æœç´¢æ¡†çŠ¶æ€æ™ºèƒ½é€‰æ‹©æ“ä½œ",
      "business_logic": "ç¡®ä¿æœç´¢æ¡†å¤„äºæ­£ç¡®çŠ¶æ€ä»¥è¿›è¡Œæœç´¢"
    },
    {
      "step": 3,
      "page": "search_page",
      "action": "click",
      "target": "search_confirm_button",
      "description": "æ‰§è¡Œæœç´¢æ“ä½œ",
      "precondition": "æœç´¢æ¡†å·²æœ‰å†…å®¹",
      "ai_hint": "å¯»æ‰¾æœç´¢ã€ç¡®è®¤ã€æ”¾å¤§é•œç­‰æŒ‰é’®"
    }
  ],
  "assertions": [
    {
      "step": 3,
      "type": "check_search_results_exist",
      "expected": true,
      "timeout": 10,
      "description": "éªŒè¯æœç´¢ç»“æœæ­£å¸¸æ˜¾ç¤º",
      "ai_understanding": "ç¡®è®¤æœç´¢åŠŸèƒ½å·¥ä½œæ­£å¸¸"
    }
  ],
  "ai_enhancement": {
    "nlp_keywords": ["æœç´¢", "è¾“å…¥", "æ¸…ç©º", "ç¡®è®¤"],
    "visual_cues": ["æœç´¢å›¾æ ‡", "è¾“å…¥æ¡†", "å–æ¶ˆæŒ‰é’®", "æ”¾å¤§é•œ"],
    "user_intent": "ç”¨æˆ·æƒ³è¦æœç´¢ç‰¹å®šå†…å®¹",
    "common_variations": [
      "æœç´¢æ¡†å¯èƒ½å·²æœ‰å†å²å†…å®¹",
      "ä¸åŒAPPçš„æœç´¢æŒ‰é’®æ ·å¼ä¸åŒ", 
      "å¯èƒ½éœ€è¦å…ˆæ¸…ç©ºå†è¾“å…¥"
    ],
    "error_patterns": [
      "æœç´¢æ¡†è¢«é”®ç›˜é®æŒ¡",
      "ç½‘ç»œå¼‚å¸¸å¯¼è‡´æœç´¢å¤±è´¥",
      "æœç´¢ç»“æœä¸ºç©º"
    ]
  },
  "llm_generation_hints": {
    "core_logic": "åˆ¤æ–­æœç´¢æ¡†çŠ¶æ€â†’é€‰æ‹©å¯¹åº”æ“ä½œâ†’æ‰§è¡Œæœç´¢",
    "decision_points": ["æœç´¢æ¡†æ˜¯å¦æœ‰å†…å®¹"],
    "alternative_flows": ["æ¸…ç©ºæµç¨‹", "ç›´æ¥è¾“å…¥æµç¨‹"],
    "success_indicators": ["æœç´¢ç»“æœåˆ—è¡¨æ˜¾ç¤º"],
    "context_dependencies": ["éœ€è¦åœ¨æœç´¢é¡µé¢", "éœ€è¦ç½‘ç»œè¿æ¥"]
  },
  "recovery_actions": [
    {
      "exception": "element_content_unclear",
      "action": "use_visual_recognition", 
      "reason": "XMLæ— æ³•å‡†ç¡®è·å–è¾“å…¥æ¡†å†…å®¹æ—¶å¯ç”¨è§†è§‰è¯†åˆ«"
    },
    {
      "exception": "conditional_logic_failed",
      "action": "fallback_to_clear_and_input",
      "reason": "åˆ¤æ–­é€»è¾‘å¤±è´¥æ—¶å¼ºåˆ¶æ¸…ç©ºåè¾“å…¥"
    }
  ]
}
```

### ğŸ¯ **æ™ºèƒ½å…ƒæ•°æ®çš„å…³é”®åˆ›æ–°**

#### 1. **æ¡ä»¶åˆ†æ”¯æ”¯æŒ**
```yaml
ä¼ ç»Ÿæ–¹å¼:
  - å›ºå®šæ­¥éª¤åºåˆ—
  - æ— æ³•å¤„ç†åŠ¨æ€å˜åŒ–

Only-Testæ–¹å¼:
  conditional_action:
    condition: "æœç´¢æ¡†æ˜¯å¦æœ‰å†…å®¹"
    if_true: "ç‚¹å‡»æ¸…ç©ºæŒ‰é’®" 
    if_false: "ç›´æ¥è¾“å…¥æœç´¢è¯"
```

#### 2. **AIå‹å¥½çš„æè¿°**
```yaml
å¤šå±‚æè¿°ä½“ç³»:
  - description: ç»™äººçœ‹çš„æè¿°
  - ai_hint: ç»™LLMçœ‹çš„æç¤º
  - business_logic: ä¸šåŠ¡é€»è¾‘è¯´æ˜
  - reason: æ“ä½œåŸå› 
```

#### 3. **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**
```yaml
context_awareness:
  - åº”ç”¨çŠ¶æ€
  - é¡µé¢çŠ¶æ€  
  - ç”¨æˆ·ä¼šè¯
  - ç½‘ç»œçŠ¶æ€
```

#### 4. **LLMç”Ÿæˆä¼˜åŒ–**
```yaml
llm_generation_hints:
  - æ ¸å¿ƒé€»è¾‘æµç¨‹
  - å…³é”®å†³ç­–ç‚¹
  - å¤‡é€‰æ–¹æ¡ˆ
  - æˆåŠŸæŒ‡æ ‡
```

### ğŸ¯ **æ‰©å±•çš„æ™ºèƒ½æ ‡ç­¾åˆ†ç±»ä½“ç³»**
```yaml
åŠŸèƒ½æ ‡ç­¾:
  - search: æœç´¢ç›¸å…³åŠŸèƒ½
  - login: ç™»å½•è®¤è¯
  - signup: æ³¨å†Œæµç¨‹  
  - live: ç›´æ’­åŠŸèƒ½
  - vod: ç‚¹æ’­åŠŸèƒ½
  - playing: æ’­æ”¾ç›¸å…³
  - subtitle: å­—å¹•åŠŸèƒ½
  - chain: é“¾è·¯æµ‹è¯•
  - other: å…¶ä»–åŠŸèƒ½

é¡µé¢æ ‡ç­¾:
  - home: é¦–é¡µ
  - search_input: æœç´¢è¾“å…¥é¡µ
  - search_result: æœç´¢ç»“æœé¡µ
  - vod_detail: ç‚¹æ’­è¯¦æƒ…é¡µ
  - playing_page: æ’­æ”¾é¡µé¢
  - user_center: ç”¨æˆ·ä¸­å¿ƒ

åŠ¨ä½œæ ‡ç­¾:
  - click: ç‚¹å‡»æ“ä½œ
  - tap: è½»è§¦
  - swipe: æ»‘åŠ¨
  - input: æ–‡æœ¬è¾“å…¥
  - long_press: é•¿æŒ‰
  - drag: æ‹–æ‹½

ä¼˜å…ˆçº§æ ‡ç­¾:
  - critical: å…³é”®åŠŸèƒ½
  - high: é«˜ä¼˜å…ˆçº§
  - medium: ä¸­ä¼˜å…ˆçº§  
  - low: ä½ä¼˜å…ˆçº§
```

---

## ğŸ¤– æ™ºèƒ½ç”¨ä¾‹ç”Ÿæˆ

### ğŸ§  **LLM é©±åŠ¨çš„ç”Ÿæˆæµç¨‹**
```
è¾“å…¥ï¼šè‡ªç„¶è¯­è¨€æè¿°
  â†“
åœºæ™¯ç†è§£ä¸è§£æ
  â†“
æµ‹è¯•è·¯å¾„è§„åˆ’
  â†“  
å…ƒæ•°æ®æ ‡å‡†åŒ–
  â†“
ä»£ç æ¨¡æ¿ç”Ÿæˆ
  â†“
è®¾å¤‡é€‚é…ä¼˜åŒ–
  â†“
è¾“å‡ºï¼šå¯æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹
```

### ğŸ“ **ç”Ÿæˆç¤ºä¾‹**
```python
# è¾“å…¥æè¿°
description = """
æµ‹è¯•åœ¨ç½‘æ˜“äº‘éŸ³ä¹ä¸­æœç´¢å¹¶æ’­æ”¾"å‘¨æ°ä¼¦"çš„æ­Œæ›²ï¼Œ
ç¡®ä¿èƒ½å¤Ÿæ­£å¸¸æ’­æ”¾ä¸”éŸ³è´¨æ¸…æ™°
"""

# LLM ç”Ÿæˆçš„ç”¨ä¾‹
generated_testcase = {
    "name": "ç½‘æ˜“äº‘éŸ³ä¹æœç´¢æ’­æ”¾æµ‹è¯•",
    "steps": [
        {"action": "launch_app", "target": "com.netease.cloudmusic"},
        {"action": "click", "target": "search_icon"},
        {"action": "input", "target": "search_box", "data": "å‘¨æ°ä¼¦"},
        {"action": "click", "target": "search_button"},
        {"action": "click", "target": "first_song_result"},
        {"action": "wait_for_playing", "timeout": 10},
    ],
    "assertions": [
        {"type": "check_is_playing", "expected": True},
        {"type": "check_has_audio", "expected": True}
    ]
}
```

### ğŸ¯ **æ™ºèƒ½ä¼˜åŒ–ç­–ç•¥**
```python
class TestCaseOptimizer:
    """æµ‹è¯•ç”¨ä¾‹æ™ºèƒ½ä¼˜åŒ–å™¨"""
    
    def optimize_for_performance(self, testcase: TestCase) -> TestCase:
        """æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘ç­‰å¾…æ—¶é—´ï¼Œä¼˜åŒ–æ“ä½œè·¯å¾„"""
        
    def optimize_for_stability(self, testcase: TestCase) -> TestCase:
        """ç¨³å®šæ€§ä¼˜åŒ–ï¼šå¢åŠ é‡è¯•æœºåˆ¶ï¼Œå¼‚å¸¸å¤„ç†"""
        
    def optimize_for_device(self, testcase: TestCase, device_type: str) -> TestCase:
        """è®¾å¤‡ä¼˜åŒ–ï¼šé€‚é…ä¸åŒå±å¹•å°ºå¯¸å’Œäº¤äº’æ–¹å¼"""
```

---

## ğŸ” å…ƒç´ è¯†åˆ«ç­–ç•¥

### ğŸ¯ **å¤šå±‚è¯†åˆ«ç­–ç•¥**
```
è¯†åˆ«ä¼˜å…ˆçº§ï¼š
1. ResourceId ç²¾ç¡®åŒ¹é… (æœ€é«˜ä¼˜å…ˆçº§)
2. Text å†…å®¹åŒ¹é… (é«˜ä¼˜å…ˆçº§)  
3. ContentDescription åŒ¹é… (ä¸­ä¼˜å…ˆçº§)
4. XPath è·¯å¾„åŒ¹é… (ä½ä¼˜å…ˆçº§)
5. è§†è§‰è¯†åˆ« (å…œåº•ç­–ç•¥)
```

### ğŸ”§ **è¯†åˆ«æ¨¡å¼åˆ‡æ¢é€»è¾‘**
```python
class RecognitionStrategy:
    def select_recognition_mode(self, context: ExecutionContext) -> RecognitionMode:
        """æ™ºèƒ½é€‰æ‹©è¯†åˆ«æ¨¡å¼"""
        
        # æ£€æŸ¥æ˜¯å¦åœ¨æ’­æ”¾çŠ¶æ€
        if context.is_media_playing():
            return RecognitionMode.VISUAL_BASED
            
        # æ£€æŸ¥ XML æ˜¯å¦å¯ç”¨
        if context.can_dump_xml():
            return RecognitionMode.XML_BASED
            
        # å…œåº•ä½¿ç”¨è§†è§‰è¯†åˆ«
        return RecognitionMode.VISUAL_BASED
        
    def fallback_recognition(self, failed_selector: ElementSelector) -> Element:
        """è¯†åˆ«å¤±è´¥æ—¶çš„é™çº§ç­–ç•¥"""
        
        strategies = [
            self._try_visual_recognition,
            self._try_coordinate_based,
            self._try_relative_positioning
        ]
        
        for strategy in strategies:
            try:
                return strategy(failed_selector)
            except ElementNotFoundError:
                continue
                
        raise ElementNotFoundError("All recognition strategies failed")
```

### ğŸ¨ **Omniparser è§†è§‰è¯†åˆ«**
```python
class VisualRecognizer:
    """åŸºäº Omniparser çš„è§†è§‰è¯†åˆ«å™¨"""
    
    def __init__(self):
        self.yolo_model = YOLOModel("models/playing_page_optimized.pt")
        self.ocr_engine = PaddleOCR(lang='ch')
        
    def recognize_elements(self, screenshot: Image) -> List[VisualElement]:
        """è¯†åˆ«å±å¹•ä¸Šçš„æ‰€æœ‰å…ƒç´ """
        
        # YOLO å›¾æ ‡è¯†åˆ«
        icons = self.yolo_model.detect_icons(screenshot)
        
        # OCR æ–‡æœ¬è¯†åˆ«  
        texts = self.ocr_engine.extract_text(screenshot)
        
        # åˆå¹¶è¯†åˆ«ç»“æœ
        return self._merge_recognition_results(icons, texts)
        
    def find_by_content(self, screenshot: Image, target_text: str) -> VisualElement:
        """æ ¹æ®å†…å®¹æŸ¥æ‰¾å…ƒç´ """
        
        elements = self.recognize_elements(screenshot)
        
        for element in elements:
            if self._text_similarity(element.text, target_text) > 0.8:
                return element
                
        raise ElementNotFoundError(f"Element with text '{target_text}' not found")
```

---

## âš¡ å¼‚å¸¸æ¢å¤æœºåˆ¶

### ğŸ›¡ï¸ **å¤šå±‚å¼‚å¸¸å¤„ç†**
```python
class ExceptionRecoveryManager:
    """å¼‚å¸¸æ¢å¤ç®¡ç†å™¨"""
    
    def handle_exception(self, exception: Exception, context: ExecutionContext):
        """ç»Ÿä¸€å¼‚å¸¸å¤„ç†å…¥å£"""
        
        recovery_strategies = {
            NetworkError: self._handle_network_error,
            ElementNotFoundError: self._handle_element_not_found,
            AppCrashError: self._handle_app_crash,
            DeviceDisconnectedError: self._handle_device_disconnect,
            TimeoutError: self._handle_timeout,
            PopupError: self._handle_unexpected_popup
        }
        
        strategy = recovery_strategies.get(type(exception))
        if strategy:
            return strategy(exception, context)
        else:
            return self._handle_unknown_error(exception, context)
    
    def _handle_network_error(self, error: NetworkError, context: ExecutionContext):
        """ç½‘ç»œå¼‚å¸¸æ¢å¤"""
        
        # 1. ç­‰å¾…ç½‘ç»œæ¢å¤
        self._wait_for_network_recovery(timeout=30)
        
        # 2. é‡è¯•å½“å‰æ“ä½œ
        return RetryAction(max_retries=3, delay=5)
    
    def _handle_element_not_found(self, error: ElementNotFoundError, context: ExecutionContext):
        """å…ƒç´ æœªæ‰¾åˆ°å¼‚å¸¸æ¢å¤"""
        
        # 1. åˆ·æ–°é¡µé¢çŠ¶æ€
        context.device.take_screenshot()
        
        # 2. åˆ‡æ¢è¯†åˆ«æ¨¡å¼
        if context.current_recognition_mode == RecognitionMode.XML_BASED:
            context.switch_recognition_mode(RecognitionMode.VISUAL_BASED)
            return RetryAction(max_retries=1)
            
        # 3. å°è¯•ç›¸ä¼¼å…ƒç´ åŒ¹é…
        similar_elements = self._find_similar_elements(error.selector)
        if similar_elements:
            return ReplaceElementAction(similar_elements[0])
            
        # 4. é‡ç½®åˆ°å·²çŸ¥çŠ¶æ€
        return ResetToHomeAction()
```

### ğŸ¯ **æ™ºèƒ½å¼¹çª—å¤„ç†**
```python
class PopupHandler:
    """æ™ºèƒ½å¼¹çª—å¤„ç†å™¨"""
    
    def __init__(self):
        self.popup_patterns = [
            {"type": "permission", "buttons": ["å…è®¸", "æˆæƒ", "ç¡®å®š"]},
            {"type": "advertisement", "buttons": ["è·³è¿‡", "å…³é—­", "Ã—"]},
            {"type": "update", "buttons": ["ç¨å", "å–æ¶ˆ", "å¿½ç•¥"]},
            {"type": "network_error", "buttons": ["é‡è¯•", "ç¡®å®š"]},
        ]
    
    def detect_and_handle_popup(self, screenshot: Image) -> bool:
        """æ£€æµ‹å¹¶å¤„ç†å¼¹çª—"""
        
        # ä½¿ç”¨ OCR è¯†åˆ«å±å¹•æ–‡æœ¬
        detected_texts = self.ocr_engine.extract_text(screenshot)
        
        for pattern in self.popup_patterns:
            if self._match_popup_pattern(detected_texts, pattern):
                return self._handle_popup(pattern, screenshot)
                
        return False
    
    def _handle_popup(self, pattern: dict, screenshot: Image) -> bool:
        """å¤„ç†ç‰¹å®šç±»å‹å¼¹çª—"""
        
        for button_text in pattern["buttons"]:
            try:
                element = self.visual_recognizer.find_by_content(screenshot, button_text)
                if element:
                    self.device.tap(element.center_x, element.center_y)
                    time.sleep(1)  # ç­‰å¾…å¼¹çª—æ¶ˆå¤±
                    return True
            except ElementNotFoundError:
                continue
                
        return False
```

---

## ğŸ“Š æ–­è¨€ä¸éªŒè¯

### âœ… **å¤šç»´åº¦æ–­è¨€ä½“ç³»**
```python
class AssertionEngine:
    """æ–­è¨€éªŒè¯å¼•æ“"""
    
    def check_is_playing(self, timeout: int = 10) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ’­æ”¾"""
        
        methods = [
            self._check_by_audio_manager,      # éŸ³é¢‘ç®¡ç†å™¨æ£€æŸ¥
            self._check_by_surface_flinger,   # Surfaceæ£€æŸ¥  
            self._check_by_screenshot_diff,   # æˆªå›¾å¯¹æ¯”
            self._check_by_sdk_status,        # SDKçŠ¶æ€æŸ¥è¯¢
        ]
        
        for method in methods:
            try:
                if method(timeout):
                    return True
            except Exception as e:
                logger.warning(f"Assertion method {method.__name__} failed: {e}")
                continue
                
        return False
    
    def check_has_audio(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æœ‰éŸ³é¢‘è¾“å‡º"""
        
        # Android AudioManager API
        audio_manager = self.device.get_audio_manager()
        return audio_manager.isMusicActive()
    
    def check_screenshot_similarity(self, 
                                  screenshot1: Image, 
                                  screenshot2: Image, 
                                  threshold: float = 0.9) -> bool:
        """æˆªå›¾ç›¸ä¼¼åº¦å¯¹æ¯”"""
        
        # ä½¿ç”¨ SSIM (Structural Similarity Index)
        similarity = self._calculate_ssim(screenshot1, screenshot2)
        return similarity >= threshold
    
    def check_content_language(self, expected_language: str) -> bool:
        """æ£€æŸ¥å†…å®¹è¯­è¨€"""
        
        screenshot = self.device.take_screenshot()
        detected_texts = self.ocr_engine.extract_text(screenshot)
        
        detected_language = self._detect_language(detected_texts)
        return detected_language == expected_language
        
    def check_element_exists(self, selector: ElementSelector, timeout: int = 5) -> bool:
        """æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨"""
        
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                element = self.element_recognizer.find_element(selector)
                return element is not None
            except ElementNotFoundError:
                time.sleep(0.5)
                continue
                
        return False
```

### ğŸ¯ **ä¸“ä¸šåŒ–éªŒè¯**
```python
class MediaAssertions:
    """åª’èµ„æ’­æ”¾ä¸“ç”¨æ–­è¨€"""
    
    def check_video_resolution(self, expected_resolution: str) -> bool:
        """æ£€æŸ¥è§†é¢‘åˆ†è¾¨ç‡"""
        
        # é€šè¿‡ SDK è·å–æ’­æ”¾å™¨çŠ¶æ€
        player_stats = self.sdk_client.get_player_statistics()
        current_resolution = f"{player_stats['width']}x{player_stats['height']}"
        return current_resolution == expected_resolution
    
    def check_audio_bitrate(self, min_bitrate: int) -> bool:
        """æ£€æŸ¥éŸ³é¢‘ç ç‡"""
        
        player_stats = self.sdk_client.get_player_statistics()
        return player_stats.get('audio_bitrate', 0) >= min_bitrate
    
    def check_buffer_health(self) -> bool:
        """æ£€æŸ¥ç¼“å†²åŒºå¥åº·çŠ¶æ€"""
        
        player_stats = self.sdk_client.get_player_statistics()
        buffer_duration = player_stats.get('buffer_duration', 0)
        return buffer_duration > 3.0  # ç¼“å†²åŒºå¤§äº3ç§’
    
    def check_playback_smooth(self, duration: int = 10) -> bool:
        """æ£€æŸ¥æ’­æ”¾æ˜¯å¦æµç•…ï¼ˆæ— å¡é¡¿ï¼‰"""
        
        initial_position = self.sdk_client.get_playback_position()
        time.sleep(duration)
        final_position = self.sdk_client.get_playback_position()
        
        # æ’­æ”¾ä½ç½®åº”è¯¥æ­£å¸¸æ¨è¿›
        expected_progress = duration * 0.8  # å…è®¸20%çš„è¯¯å·®
        actual_progress = final_position - initial_position
        
        return actual_progress >= expected_progress
```

---

## ğŸ“± å‰ç½®æ¡ä»¶ä¼˜åŒ–

### ğŸš€ **SDK é›†æˆæ–¹æ¡ˆ**
```python
class TestSDK:
    """æµ‹è¯•ä¸“ç”¨ SDKï¼Œé›†æˆåˆ° APK ä¸­"""
    
    def __init__(self):
        self.mock_server = MockServer()
        self.state_manager = AppStateManager()
        
    def inject_login_token(self, token: str, user_profile: dict):
        """æ³¨å…¥ç™»å½•å‡­è¯"""
        
        # ç›´æ¥è®¾ç½®å†…å­˜ä¸­çš„è®¤è¯çŠ¶æ€
        self.state_manager.set_auth_token(token)
        self.state_manager.set_user_profile(user_profile)
        
        # ç»•è¿‡ç½‘ç»œç™»å½•æµç¨‹
        return {"status": "success", "login_time": time.time()}
    
    def mock_network_response(self, url_pattern: str, response_data: dict):
        """Mock ç½‘ç»œè¯·æ±‚å“åº”"""
        
        # æ‹¦æˆªç½‘ç»œè¯·æ±‚å¹¶è¿”å›é¢„è®¾æ•°æ®
        self.mock_server.add_mock_rule(url_pattern, response_data)
        
    def simulate_network_error(self, error_type: str, duration: int = 5):
        """æ¨¡æ‹Ÿç½‘ç»œå¼‚å¸¸"""
        
        error_types = {
            "timeout": self._simulate_timeout,
            "disconnect": self._simulate_disconnect,
            "slow": self._simulate_slow_network
        }
        
        if error_type in error_types:
            error_types[error_type](duration)
    
    def get_player_internal_state(self) -> dict:
        """è·å–æ’­æ”¾å™¨å†…éƒ¨çŠ¶æ€"""
        
        # ç»•è¿‡ DRM é™åˆ¶ï¼Œç›´æ¥æŸ¥è¯¢æ’­æ”¾å™¨å†…æ ¸
        return {
            "is_playing": self._get_player_playing_state(),
            "current_position": self._get_playback_position(),
            "buffer_level": self._get_buffer_level(),
            "video_resolution": self._get_video_resolution(),
            "audio_codec": self._get_audio_codec(),
            "error_code": self._get_last_error_code()
        }
```

### ğŸ¯ **Deeplink å¿«é€Ÿå¯¼èˆª**
```python
class DeeplinkManager:
    """Deeplink å¯¼èˆªç®¡ç†å™¨"""
    
    def __init__(self):
        self.deeplink_patterns = {
            "home": "unimob://main/home",
            "search": "unimob://search?query={query}",
            "vod_detail": "unimob://vod/detail/{program_id}",
            "playing": "unimob://player/play/{media_id}",
            "user_center": "unimob://user/profile",
            "settings": "unimob://settings/general"
        }
    
    def navigate_to_page(self, page_name: str, params: dict = None) -> bool:
        """é€šè¿‡ Deeplink å¯¼èˆªåˆ°æŒ‡å®šé¡µé¢"""
        
        if page_name not in self.deeplink_patterns:
            raise ValueError(f"Unknown page: {page_name}")
            
        deeplink = self.deeplink_patterns[page_name]
        
        # å¡«å……å‚æ•°
        if params:
            deeplink = deeplink.format(**params)
            
        # æ‰§è¡Œ deeplink è·³è½¬
        return self.device.launch_deeplink(deeplink)
    
    def create_test_data_deeplink(self, test_scenario: str) -> str:
        """ç”Ÿæˆå¸¦æµ‹è¯•æ•°æ®çš„ Deeplink"""
        
        test_data = self.test_data_manager.get_data_for_scenario(test_scenario)
        deeplink = f"unimob://test/setup?data={base64.b64encode(json.dumps(test_data))}"
        return deeplink
```

---

## ğŸ”„ ç”¨ä¾‹æ‰§è¡Œæµç¨‹

### âš™ï¸ **æ‰§è¡Œå¼•æ“æ¶æ„**
```python
class ExecutionEngine:
    """æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œå¼•æ“"""
    
    def __init__(self):
        self.device_pool = DevicePool()
        self.element_recognizer = ElementRecognizer()
        self.assertion_engine = AssertionEngine()
        self.recovery_manager = ExceptionRecoveryManager()
        self.reporter = TestReporter()
        
    def execute_testcase(self, testcase: TestCase) -> TestResult:
        """æ‰§è¡Œå•ä¸ªæµ‹è¯•ç”¨ä¾‹"""
        
        result = TestResult(testcase.id)
        device = None
        
        try:
            # 1. è·å–è®¾å¤‡
            device = self.device_pool.acquire_device(testcase.device_requirements)
            result.device_info = device.get_info()
            
            # 2. ç¯å¢ƒå‡†å¤‡
            self._prepare_test_environment(testcase, device)
            
            # 3. æ‰§è¡Œæ­¥éª¤
            for step in testcase.steps:
                step_result = self._execute_step(step, device)
                result.add_step_result(step_result)
                
                if step_result.status == StepStatus.FAILED:
                    # å°è¯•å¼‚å¸¸æ¢å¤
                    recovery_action = self.recovery_manager.handle_exception(
                        step_result.exception, 
                        ExecutionContext(device, step, testcase)
                    )
                    
                    if recovery_action.should_retry:
                        step_result = self._execute_step(step, device, recovery_action)
                        result.update_step_result(step.id, step_result)
                    
                    if step_result.status == StepStatus.FAILED and step.is_critical:
                        result.status = TestStatus.FAILED
                        break
            
            # 4. æ–­è¨€éªŒè¯
            for assertion in testcase.assertions:
                assertion_result = self._execute_assertion(assertion, device)
                result.add_assertion_result(assertion_result)
                
            # 5. æ¸…ç†ç¯å¢ƒ
            self._cleanup_test_environment(testcase, device)
            
            # 6. ç¡®å®šæœ€ç»ˆç»“æœ
            result.finalize()
            
        except Exception as e:
            result.status = TestStatus.ERROR
            result.error_message = str(e)
            logger.error(f"Test execution failed: {e}")
            
        finally:
            if device:
                self.device_pool.release_device(device)
                
        return result
```

### ğŸ¯ **å¹¶å‘æ‰§è¡Œç®¡ç†**
```python
class ParallelExecutionManager:
    """å¹¶å‘æ‰§è¡Œç®¡ç†å™¨"""
    
    def __init__(self, max_concurrent_devices: int = 5):
        self.max_concurrent = max_concurrent_devices
        self.execution_queue = Queue()
        self.result_collector = ResultCollector()
        
    def execute_test_suite(self, test_suite: TestSuite) -> SuiteResult:
        """å¹¶å‘æ‰§è¡Œæµ‹è¯•å¥—ä»¶"""
        
        # 1. åˆ†æä¾èµ–å…³ç³»
        execution_graph = self._build_execution_graph(test_suite)
        
        # 2. æŒ‰æ‰¹æ¬¡æ‰§è¡Œ
        suite_result = SuiteResult(test_suite.id)
        
        for batch in execution_graph.get_execution_batches():
            batch_futures = []
            
            with ThreadPoolExecutor(max_workers=self.max_concurrent) as executor:
                for testcase in batch:
                    future = executor.submit(self._execute_with_monitoring, testcase)
                    batch_futures.append(future)
                
                # ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                for future in as_completed(batch_futures):
                    result = future.result()
                    suite_result.add_test_result(result)
        
        return suite_result
    
    def _execute_with_monitoring(self, testcase: TestCase) -> TestResult:
        """å¸¦ç›‘æ§çš„æ‰§è¡Œ"""
        
        monitor = ExecutionMonitor(testcase)
        
        try:
            monitor.start()
            result = self.execution_engine.execute_testcase(testcase)
            monitor.record_success(result)
            return result
            
        except Exception as e:
            monitor.record_failure(e)
            raise
            
        finally:
            monitor.stop()
```

---

## ğŸ“ˆ ç›‘æ§ä¸æŠ¥å‘Š

### ğŸ“Š **å®æ—¶ç›‘æ§é¢æ¿**
```python
class MonitoringDashboard:
    """æµ‹è¯•æ‰§è¡Œç›‘æ§é¢æ¿"""
    
    def __init__(self):
        self.metrics_collector = MetricsCollector()
        self.alert_manager = AlertManager()
        self.websocket_server = WebSocketServer(port=8080)
        
    def start_monitoring(self, test_suite: TestSuite):
        """å¼€å§‹ç›‘æ§æµ‹è¯•å¥—ä»¶æ‰§è¡Œ"""
        
        # å¯åŠ¨å®æ—¶æ•°æ®æ”¶é›†
        self.metrics_collector.start_collection()
        
        # æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
        self._register_event_listeners()
        
        # å¯åŠ¨ WebSocket æœåŠ¡å™¨
        self.websocket_server.start()
        
    def get_real_time_metrics(self) -> dict:
        """è·å–å®æ—¶ç›‘æ§æŒ‡æ ‡"""
        
        return {
            "total_tests": self.metrics_collector.get_total_test_count(),
            "passed_tests": self.metrics_collector.get_passed_count(),
            "failed_tests": self.metrics_collector.get_failed_count(),
            "execution_time": self.metrics_collector.get_total_execution_time(),
            "device_utilization": self.metrics_collector.get_device_utilization(),
            "success_rate": self.metrics_collector.get_success_rate(),
            "avg_test_duration": self.metrics_collector.get_avg_test_duration(),
            "current_status": self.metrics_collector.get_current_status()
        }
        
    def generate_failure_analysis(self, failed_results: List[TestResult]) -> FailureAnalysis:
        """ç”Ÿæˆå¤±è´¥åˆ†ææŠ¥å‘Š"""
        
        analysis = FailureAnalysis()
        
        # åˆ†æå¤±è´¥æ¨¡å¼
        failure_patterns = self._analyze_failure_patterns(failed_results)
        analysis.add_patterns(failure_patterns)
        
        # è®¾å¤‡ç›¸å…³åˆ†æ
        device_issues = self._analyze_device_issues(failed_results)
        analysis.add_device_issues(device_issues)
        
        # æ—¶é—´ç›¸å…³åˆ†æ
        timing_issues = self._analyze_timing_issues(failed_results)
        analysis.add_timing_issues(timing_issues)
        
        return analysis
```

### ğŸ“‹ **è¯¦ç»†æµ‹è¯•æŠ¥å‘Š**
```python
class TestReporter:
    """æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨"""
    
    def generate_html_report(self, suite_result: SuiteResult) -> str:
        """ç”Ÿæˆ HTML æ ¼å¼æŠ¥å‘Š"""
        
        template = self._load_html_template()
        
        report_data = {
            "suite_name": suite_result.suite_name,
            "execution_time": suite_result.total_execution_time,
            "summary": self._generate_summary(suite_result),
            "test_results": self._format_test_results(suite_result.test_results),
            "failure_analysis": self._generate_failure_analysis(suite_result),
            "device_info": self._collect_device_info(suite_result),
            "charts": self._generate_charts(suite_result)
        }
        
        return template.render(report_data)
    
    def generate_json_report(self, suite_result: SuiteResult) -> dict:
        """ç”Ÿæˆ JSON æ ¼å¼æŠ¥å‘Š"""
        
        return {
            "metadata": {
                "suite_id": suite_result.suite_id,
                "execution_timestamp": suite_result.start_time.isoformat(),
                "total_duration": suite_result.total_execution_time,
                "framework_version": __version__
            },
            "summary": {
                "total_tests": len(suite_result.test_results),
                "passed": suite_result.passed_count,
                "failed": suite_result.failed_count,
                "skipped": suite_result.skipped_count,
                "success_rate": suite_result.success_rate
            },
            "test_results": [
                self._serialize_test_result(result) 
                for result in suite_result.test_results
            ],
            "failure_analysis": self._analyze_failures(suite_result),
            "performance_metrics": self._collect_performance_metrics(suite_result)
        }
```

---

## ğŸ› ï¸ å¼€å‘å·¥å…·é“¾

### ğŸ¨ **å¯è§†åŒ–ç”¨ä¾‹ç¼–è¾‘å™¨**
```python
class VisualTestCaseEditor:
    """å¯è§†åŒ–æµ‹è¯•ç”¨ä¾‹ç¼–è¾‘å™¨"""
    
    def __init__(self):
        self.ui_recorder = UIRecorder()
        self.element_inspector = ElementInspector()
        self.code_generator = CodeGenerator()
        
    def start_recording_session(self, device: Device) -> RecordingSession:
        """å¼€å§‹å½•åˆ¶æµ‹è¯•ä¼šè¯"""
        
        session = RecordingSession(device)
        
        # å¯åŠ¨å±å¹•å½•åˆ¶
        session.start_screen_recording()
        
        # å¯åŠ¨äº‹ä»¶ç›‘å¬
        session.start_event_listening()
        
        return session
    
    def generate_testcase_from_recording(self, session: RecordingSession) -> TestCase:
        """ä»å½•åˆ¶ä¼šè¯ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹"""
        
        # åˆ†æå½•åˆ¶çš„æ“ä½œåºåˆ—
        actions = self._analyze_recorded_actions(session.recorded_events)
        
        # è¯†åˆ«é¡µé¢è½¬æ¢
        page_transitions = self._identify_page_transitions(session.screenshots)
        
        # ç”Ÿæˆæµ‹è¯•æ­¥éª¤
        test_steps = self._generate_test_steps(actions, page_transitions)
        
        # è‡ªåŠ¨ç”Ÿæˆæ–­è¨€
        assertions = self._generate_assertions(session)
        
        return TestCase(
            name=session.name,
            steps=test_steps,
            assertions=assertions,
            metadata=session.metadata
        )
```

### ğŸ“± **è®¾å¤‡ç®¡ç†æ§åˆ¶å°**
```python
class DeviceManagementConsole:
    """è®¾å¤‡ç®¡ç†æ§åˆ¶å°"""
    
    def __init__(self):
        self.device_discovery = DeviceDiscovery()
        self.device_pool = DevicePool()
        self.health_monitor = DeviceHealthMonitor()
        
    def discover_devices(self) -> List[Device]:
        """å‘ç°å¯ç”¨è®¾å¤‡"""
        
        discovered = []
        
        # ADB è®¾å¤‡å‘ç°
        adb_devices = self.device_discovery.find_adb_devices()
        discovered.extend(adb_devices)
        
        # äº‘è®¾å¤‡å‘ç°  
        cloud_devices = self.device_discovery.find_cloud_devices()
        discovered.extend(cloud_devices)
        
        # æ¨¡æ‹Ÿå™¨å‘ç°
        emulator_devices = self.device_discovery.find_emulators()
        discovered.extend(emulator_devices)
        
        return discovered
    
    def setup_device_farm(self, device_configs: List[DeviceConfig]):
        """è®¾ç½®è®¾å¤‡å†œåœº"""
        
        for config in device_configs:
            device = self._initialize_device(config)
            
            # å¥åº·æ£€æŸ¥
            if self.health_monitor.check_device_health(device):
                self.device_pool.add_device(device)
            else:
                logger.warning(f"Device {device.id} failed health check")
    
    def monitor_device_health(self):
        """ç›‘æ§è®¾å¤‡å¥åº·çŠ¶æ€"""
        
        while True:
            for device in self.device_pool.get_all_devices():
                health_status = self.health_monitor.check_device_health(device)
                
                if not health_status.is_healthy:
                    self._handle_unhealthy_device(device, health_status)
                    
            time.sleep(30)  # æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
```

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ğŸ“¦ **å®‰è£…éƒ¨ç½²**
```bash
# 1. å…‹éš†é¡¹ç›®
git clone https://github.com/your-org/only-test.git
cd only-test

# 2. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 3. å®‰è£… Only-Test æ¡†æ¶
pip install -e .

# 4. åˆå§‹åŒ–é…ç½®
only-test init --config-dir ./config

# 5. å¯åŠ¨è®¾å¤‡å‘ç°
only-test devices discover

# 6. è¿è¡Œç¤ºä¾‹æµ‹è¯•
only-test run --suite examples/vod_playback_suite.yaml
```

### âš™ï¸ **é…ç½®æ–‡ä»¶**
```yaml
# config/only-test.yaml
framework:
  version: "1.0.0"
  log_level: "INFO"
  report_format: ["html", "json"]
  
devices:
  discovery:
    adb_enabled: true
    cloud_enabled: false
    emulator_enabled: true
  pool:
    max_concurrent: 5
    health_check_interval: 30
    
recognition:
  default_mode: "hybrid"
  xml_timeout: 10
  visual_timeout: 30
  fallback_enabled: true
  
execution:
  retry_count: 3
  step_timeout: 30
  assertion_timeout: 10
  recovery_enabled: true
  
reporting:
  output_dir: "./reports"
  real_time_monitoring: true
  failure_analysis: true
```

### ğŸ¯ **åˆ›å»ºç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹**
```python
# tests/test_vod_playback.py
from only_test import TestCase, TestStep, Assertion

def create_vod_playback_test():
    """åˆ›å»ºç‚¹æ’­æ’­æ”¾æµ‹è¯•ç”¨ä¾‹"""
    
    testcase = TestCase(
        name="ç‚¹æ’­èŠ‚ç›®æ’­æ”¾åŠŸèƒ½æµ‹è¯•",
        tags=["vod", "playback", "basic"],
        device_types=["android_phone", "android_tv"]
    )
    
    # æ·»åŠ æµ‹è¯•æ­¥éª¤
    testcase.add_step(TestStep(
        action="launch_app",
        target="com.example.iptv",
        description="å¯åŠ¨ IPTV åº”ç”¨"
    ))
    
    testcase.add_step(TestStep(
        action="click",
        target={"resource_id": "search_button"},
        description="ç‚¹å‡»æœç´¢æŒ‰é’®"
    ))
    
    testcase.add_step(TestStep(
        action="input",
        target={"resource_id": "search_input"},
        data="æµ‹è¯•èŠ‚ç›®",
        description="è¾“å…¥æœç´¢å†…å®¹"
    ))
    
    testcase.add_step(TestStep(
        action="click", 
        target={"text": "æœç´¢"},
        description="ç‚¹å‡»æœç´¢"
    ))
    
    testcase.add_step(TestStep(
        action="click",
        target={"xpath": "//android.widget.TextView[1]"},
        description="ç‚¹å‡»ç¬¬ä¸€ä¸ªæœç´¢ç»“æœ"
    ))
    
    testcase.add_step(TestStep(
        action="click",
        target={"content_desc": "æ’­æ”¾æŒ‰é’®"},
        description="ç‚¹å‡»æ’­æ”¾æŒ‰é’®"
    ))
    
    # æ·»åŠ æ–­è¨€
    testcase.add_assertion(Assertion(
        type="check_is_playing",
        expected=True,
        timeout=30,
        description="éªŒè¯è§†é¢‘å¼€å§‹æ’­æ”¾"
    ))
    
    testcase.add_assertion(Assertion(
        type="check_has_audio", 
        expected=True,
        description="éªŒè¯æœ‰éŸ³é¢‘è¾“å‡º"
    ))
    
    return testcase

if __name__ == "__main__":
    test = create_vod_playback_test()
    test.save("test_vod_playback.json")
```

### ğŸ¤– **ä½¿ç”¨ LLM ç”Ÿæˆç”¨ä¾‹**
```python
# examples/llm_generation.py
from only_test import LLMTestCaseGenerator

def generate_test_with_llm():
    """ä½¿ç”¨ LLM ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹"""
    
    generator = LLMTestCaseGenerator(
        model="gpt-4",
        api_key="your-api-key"
    )
    
    # è‡ªç„¶è¯­è¨€æè¿°
    description = """
    åœ¨çˆ±å¥‡è‰º APP ä¸­æœç´¢ç”µå½±"å¤ä»‡è€…è”ç›Ÿ"ï¼Œ
    é€‰æ‹©ç¬¬ä¸€ä¸ªç»“æœè¿›å…¥è¯¦æƒ…é¡µï¼Œ
    ç‚¹å‡»æ’­æ”¾æŒ‰é’®å¼€å§‹è§‚çœ‹ï¼Œ
    éªŒè¯è§†é¢‘èƒ½å¤Ÿæ­£å¸¸æ’­æ”¾ä¸”ç”»è´¨æ¸…æ™°
    """
    
    # ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
    testcase = generator.generate_from_description(
        description=description,
        app_package="com.qiyi.video",
        device_type="android_phone"
    )
    
    # ä¿å­˜ç”Ÿæˆçš„ç”¨ä¾‹
    testcase.save("generated_iqiyi_test.json")
    
    print(f"Generated test case: {testcase.name}")
    print(f"Steps: {len(testcase.steps)}")
    print(f"Assertions: {len(testcase.assertions)}")
    
    return testcase

if __name__ == "__main__":
    generate_test_with_llm()
```

---

## ğŸ“š æŠ€æœ¯å®ç°

### ğŸ”§ **æ¶æ„ç»„ä»¶è¯¦è§£**

#### 1. **å…ƒç´ è¯†åˆ«å¼•æ“**
```python
class UnifiedElementRecognizer:
    """ç»Ÿä¸€å…ƒç´ è¯†åˆ«å¼•æ“"""
    
    def __init__(self):
        self.xml_recognizer = UIAutomator2Recognizer()
        self.visual_recognizer = OmniparserRecognizer()
        self.recognition_mode = RecognitionMode.HYBRID
        
    def find_element(self, selector: ElementSelector) -> Element:
        """ç»Ÿä¸€å…ƒç´ æŸ¥æ‰¾æ¥å£"""
        
        if self.recognition_mode == RecognitionMode.XML_BASED:
            return self._find_by_xml(selector)
        elif self.recognition_mode == RecognitionMode.VISUAL_BASED:
            return self._find_by_vision(selector)
        else:  # HYBRID æ¨¡å¼
            return self._find_by_hybrid(selector)
    
    def _find_by_hybrid(self, selector: ElementSelector) -> Element:
        """æ··åˆæ¨¡å¼æŸ¥æ‰¾"""
        
        # 1. ä¼˜å…ˆå°è¯• XML è¯†åˆ«ï¼ˆé€Ÿåº¦å¿«ï¼‰
        try:
            if self.xml_recognizer.can_dump_xml():
                element = self.xml_recognizer.find_element(selector)
                if element and self._verify_element_visibility(element):
                    return element
        except ElementNotFoundError:
            pass
            
        # 2. é™çº§åˆ°è§†è§‰è¯†åˆ«
        try:
            return self.visual_recognizer.find_element(selector)
        except ElementNotFoundError:
            pass
            
        # 3. æœ€åå°è¯•åæ ‡å®šä½
        if selector.has_coordinates():
            return CoordinateElement(selector.x, selector.y)
            
        raise ElementNotFoundError(f"Element not found: {selector}")
```

#### 2. **è®¾å¤‡æŠ½è±¡å±‚**
```python
class UniversalDeviceAdapter:
    """é€šç”¨è®¾å¤‡é€‚é…å™¨"""
    
    def __init__(self, device_type: str):
        self.device_type = device_type
        self.driver = self._create_driver(device_type)
        self.capabilities = self._detect_capabilities()
        
    def _create_driver(self, device_type: str) -> DeviceDriver:
        """æ ¹æ®è®¾å¤‡ç±»å‹åˆ›å»ºé©±åŠ¨"""
        
        drivers = {
            "android_phone": AndroidPhoneDriver,
            "android_tablet": AndroidTabletDriver,
            "android_tv": AndroidTVDriver,
            "emulator": EmulatorDriver,
            "cloud_device": CloudDeviceDriver
        }
        
        driver_class = drivers.get(device_type)
        if not driver_class:
            raise ValueError(f"Unsupported device type: {device_type}")
            
        return driver_class()
    
    def tap(self, x: int, y: int) -> bool:
        """ç»Ÿä¸€ç‚¹å‡»æ¥å£"""
        
        # æ ¹æ®è®¾å¤‡ç±»å‹è°ƒæ•´ç‚¹å‡»æ–¹å¼
        if self.device_type == "android_tv":
            # TV è®¾å¤‡å¯èƒ½éœ€è¦æ¨¡æ‹Ÿé¥æ§å™¨æ“ä½œ
            return self._simulate_remote_control_click(x, y)
        else:
            # æ‰‹æœº/å¹³æ¿ä½¿ç”¨è§¦æ‘¸æ“ä½œ
            return self.driver.tap(x, y)
    
    def adapt_coordinates(self, x: int, y: int) -> Tuple[int, int]:
        """åæ ‡é€‚é…"""
        
        current_resolution = self.get_screen_resolution()
        reference_resolution = (1920, 1080)  # å‚è€ƒåˆ†è¾¨ç‡
        
        # è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
        scale_x = current_resolution[0] / reference_resolution[0]
        scale_y = current_resolution[1] / reference_resolution[1]
        
        # é€‚é…åæ ‡
        adapted_x = int(x * scale_x)
        adapted_y = int(y * scale_y)
        
        return adapted_x, adapted_y
```

#### 3. **ç”¨ä¾‹ç”Ÿæˆå¼•æ“**
```python
class LLMTestCaseGenerator:
    """åŸºäº LLM çš„æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆå¼•æ“"""
    
    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client
        self.template_engine = TemplateEngine()
        self.metadata_extractor = MetadataExtractor()
        
    def generate_from_description(self, description: str, context: dict) -> TestCase:
        """ä»è‡ªç„¶è¯­è¨€æè¿°ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹"""
        
        # 1. æ„å»ºæç¤ºè¯
        prompt = self._build_generation_prompt(description, context)
        
        # 2. LLM ç”Ÿæˆ
        llm_response = self.llm_client.generate(prompt)
        
        # 3. è§£æç”Ÿæˆç»“æœ
        raw_testcase = self._parse_llm_response(llm_response)
        
        # 4. æ ‡å‡†åŒ–å¤„ç†
        standardized_testcase = self._standardize_testcase(raw_testcase)
        
        # 5. éªŒè¯å’Œä¼˜åŒ–
        optimized_testcase = self._optimize_testcase(standardized_testcase, context)
        
        return optimized_testcase
    
    def _build_generation_prompt(self, description: str, context: dict) -> str:
        """æ„å»ºç”Ÿæˆæç¤ºè¯"""
        
        template = """
        ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç§»åŠ¨åº”ç”¨è‡ªåŠ¨åŒ–æµ‹è¯•å·¥ç¨‹å¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹æè¿°ç”Ÿæˆè¯¦ç»†çš„æµ‹è¯•ç”¨ä¾‹ã€‚

        æµ‹è¯•æè¿°ï¼š{description}

        åº”ç”¨ä¿¡æ¯ï¼š
        - åŒ…åï¼š{package_name}
        - è®¾å¤‡ç±»å‹ï¼š{device_type}
        - åº”ç”¨ç±»å‹ï¼š{app_type}

        è¯·æŒ‰ç…§ä»¥ä¸‹ JSON æ ¼å¼ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ï¼š
        {{
            "name": "æµ‹è¯•ç”¨ä¾‹åç§°",
            "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
            "steps": [
                {{
                    "action": "åŠ¨ä½œç±»å‹",
                    "target": {{"resource_id": "å…ƒç´ ID"}},
                    "data": "è¾“å…¥æ•°æ®ï¼ˆå¯é€‰ï¼‰",
                    "description": "æ­¥éª¤æè¿°"
                }}
            ],
            "assertions": [
                {{
                    "type": "æ–­è¨€ç±»å‹", 
                    "expected": "æœŸæœ›å€¼",
                    "description": "æ–­è¨€æè¿°"
                }}
            ]
        }}

        è¦æ±‚ï¼š
        1. æ­¥éª¤è¦è¯¦ç»†ä¸”å¯æ‰§è¡Œ
        2. å…ƒç´ å®šä½è¦å‡†ç¡®
        3. æ–­è¨€è¦åˆç†ä¸”å……åˆ†
        4. è€ƒè™‘å¼‚å¸¸æƒ…å†µå’Œæ¢å¤æœºåˆ¶
        """
        
        return template.format(
            description=description,
            package_name=context.get("package_name", "unknown"),
            device_type=context.get("device_type", "android_phone"),
            app_type=context.get("app_type", "iptv")
        )
```

### ğŸ¯ **æ ¸å¿ƒç®—æ³•**

#### 1. **æ™ºèƒ½å…ƒç´ åŒ¹é…ç®—æ³•**
```python
class SmartElementMatcher:
    """æ™ºèƒ½å…ƒç´ åŒ¹é…å™¨"""
    
    def __init__(self):
        self.similarity_calculator = SimilarityCalculator()
        self.confidence_threshold = 0.8
        
    def find_best_match(self, target_selector: ElementSelector, 
                       candidates: List[Element]) -> Optional[Element]:
        """æ‰¾åˆ°æœ€ä½³åŒ¹é…å…ƒç´ """
        
        if not candidates:
            return None
            
        scored_candidates = []
        
        for candidate in candidates:
            score = self._calculate_match_score(target_selector, candidate)
            scored_candidates.append((candidate, score))
            
        # æŒ‰åˆ†æ•°æ’åº
        scored_candidates.sort(key=lambda x: x[1], reverse=True)
        
        best_candidate, best_score = scored_candidates[0]
        
        # æ£€æŸ¥ç½®ä¿¡åº¦
        if best_score >= self.confidence_threshold:
            return best_candidate
        else:
            return None
    
    def _calculate_match_score(self, selector: ElementSelector, element: Element) -> float:
        """è®¡ç®—åŒ¹é…åˆ†æ•°"""
        
        score = 0.0
        weight_sum = 0.0
        
        # æ–‡æœ¬åŒ¹é…æƒé‡ï¼š40%
        if selector.text and element.text:
            text_similarity = self.similarity_calculator.text_similarity(
                selector.text, element.text
            )
            score += text_similarity * 0.4
            weight_sum += 0.4
            
        # ResourceID åŒ¹é…æƒé‡ï¼š30%
        if selector.resource_id and element.resource_id:
            if selector.resource_id == element.resource_id:
                score += 1.0 * 0.3
            weight_sum += 0.3
            
        # å†…å®¹æè¿°åŒ¹é…æƒé‡ï¼š20%
        if selector.content_desc and element.content_desc:
            desc_similarity = self.similarity_calculator.text_similarity(
                selector.content_desc, element.content_desc
            )
            score += desc_similarity * 0.2
            weight_sum += 0.2
            
        # ä½ç½®åŒ¹é…æƒé‡ï¼š10%
        if selector.bounds and element.bounds:
            position_similarity = self.similarity_calculator.position_similarity(
                selector.bounds, element.bounds
            )
            score += position_similarity * 0.1
            weight_sum += 0.1
            
        # å½’ä¸€åŒ–åˆ†æ•°
        return score / weight_sum if weight_sum > 0 else 0.0
```

#### 2. **è‡ªé€‚åº”ç­‰å¾…ç­–ç•¥**
```python
class AdaptiveWaitStrategy:
    """è‡ªé€‚åº”ç­‰å¾…ç­–ç•¥"""
    
    def __init__(self):
        self.base_timeout = 10
        self.max_timeout = 60
        self.polling_interval = 0.5
        
    def wait_for_element(self, selector: ElementSelector, 
                        context: ExecutionContext) -> Element:
        """è‡ªé€‚åº”ç­‰å¾…å…ƒç´ å‡ºç°"""
        
        # æ ¹æ®å†å²æ•°æ®è°ƒæ•´è¶…æ—¶æ—¶é—´
        adjusted_timeout = self._calculate_adaptive_timeout(selector, context)
        
        start_time = time.time()
        last_exception = None
        
        while time.time() - start_time < adjusted_timeout:
            try:
                element = context.element_recognizer.find_element(selector)
                if element and self._is_element_ready(element):
                    return element
                    
            except Exception as e:
                last_exception = e
                
            # æ™ºèƒ½è°ƒæ•´è½®è¯¢é—´éš”
            interval = self._calculate_polling_interval(context)
            time.sleep(interval)
            
        # è¶…æ—¶åæŠ›å‡ºæœ€åä¸€æ¬¡å¼‚å¸¸
        if last_exception:
            raise last_exception
        else:
            raise TimeoutError(f"Element not found within {adjusted_timeout}s: {selector}")
    
    def _calculate_adaptive_timeout(self, selector: ElementSelector, 
                                  context: ExecutionContext) -> float:
        """è®¡ç®—è‡ªé€‚åº”è¶…æ—¶æ—¶é—´"""
        
        # è·å–å†å²æ•°æ®
        historical_data = context.performance_tracker.get_historical_data(selector)
        
        if historical_data:
            # åŸºäºå†å²æ•°æ®çš„ P95 å€¼è®¡ç®—è¶…æ—¶æ—¶é—´
            p95_time = np.percentile(historical_data, 95)
            adaptive_timeout = min(max(p95_time * 1.5, self.base_timeout), self.max_timeout)
        else:
            adaptive_timeout = self.base_timeout
            
        # æ ¹æ®å½“å‰ç³»ç»Ÿè´Ÿè½½è°ƒæ•´
        system_load = context.system_monitor.get_current_load()
        if system_load > 0.8:
            adaptive_timeout *= 1.5
            
        return adaptive_timeout
```

---

## ğŸ¯ ä¸ä¼ ç»Ÿæ–¹æ¡ˆå¯¹æ¯”

### ğŸ“Š **å…¨æ–¹ä½å¯¹æ¯”åˆ†æ**

| å¯¹æ¯”ç»´åº¦ | ä¼ ç»Ÿ Airtest/Appium | Only-Test æ¡†æ¶ |
|---------|-------------------|----------------|
| **è·¨ APK å¤ç”¨** | âŒ éœ€è¦é‡æ–°å½•åˆ¶é€‚é… | âœ… ä¸€æ¬¡ç¼–å†™ï¼Œåˆ°å¤„è¿è¡Œ |
| **è·¨è®¾å¤‡æ”¯æŒ** | âŒ åˆ†è¾¨ç‡ä¾èµ–ä¸¥é‡ | âœ… æ™ºèƒ½åæ ‡é€‚é… |
| **æ’­æ”¾çŠ¶æ€è¯†åˆ«** | âŒ XML dump å¤±è´¥ | âœ… è§†è§‰è¯†åˆ« + SDK é›†æˆ |
| **DRM å†…å®¹æµ‹è¯•** | âŒ æ— æ³•æˆªå›¾éªŒè¯ | âœ… ç™½ç›’æµ‹è¯•ç»•è¿‡ |
| **æ™ºèƒ½ç”Ÿæˆ** | âŒ çº¯æ‰‹å·¥ç¼–å†™ | âœ… LLM è¾…åŠ©ç”Ÿæˆ |
| **å¼‚å¸¸æ¢å¤** | âš ï¸ åŸºç¡€å¼‚å¸¸å¤„ç† | âœ… æ™ºèƒ½å¼‚å¸¸æ¢å¤ |
| **ç»´æŠ¤æˆæœ¬** | ğŸ“ˆ éšç”¨ä¾‹æ•°é‡çº¿æ€§å¢é•¿ | ğŸ“‰ æ¡†æ¶åŒ–ç®¡ç† |
| **æ‰§è¡Œç¨³å®šæ€§** | âš ï¸ å…ƒç´ å˜åŒ–æ•æ„Ÿ | âœ… å¤šå±‚é™çº§ç­–ç•¥ |
| **å­¦ä¹ æˆæœ¬** | ğŸ“š éœ€è¦æ·±å…¥å­¦ä¹ å·¥å…· | ğŸš€ è‡ªç„¶è¯­è¨€æè¿° |

### ğŸ’° **æŠ•å…¥äº§å‡ºæ¯”åˆ†æ**

#### **ä¼ ç»Ÿæ–¹æ¡ˆ TCOï¼ˆæ€»æ‹¥æœ‰æˆæœ¬ï¼‰**
```
åˆæœŸæŠ•å…¥ï¼š
- å·¥å…·å­¦ä¹ æˆæœ¬ï¼š40 äººæ—¶
- ç”¨ä¾‹å¼€å‘ï¼šæ¯ä¸ª APK 120 äººæ—¶
- ç¯å¢ƒæ­å»ºï¼š20 äººæ—¶

ç»´æŠ¤æˆæœ¬ï¼ˆå¹´ï¼‰ï¼š
- ç”¨ä¾‹ç»´æŠ¤ï¼šæ¯ä¸ª APK 60 äººæ—¶/å¹´  
- å·¥å…·å‡çº§é€‚é…ï¼š40 äººæ—¶/å¹´
- é—®é¢˜æ’æŸ¥ä¿®å¤ï¼š80 äººæ—¶/å¹´

ä»¥ 10 ä¸ª APK ä¸ºä¾‹ï¼š
åˆæœŸï¼š40 + 120*10 + 20 = 1260 äººæ—¶
å¹´åº¦ï¼š(60 + 40 + 80)*10 = 1800 äººæ—¶/å¹´
```

#### **Only-Test æ–¹æ¡ˆ TCO**
```
åˆæœŸæŠ•å…¥ï¼š
- æ¡†æ¶æ­å»ºï¼š200 äººæ—¶ï¼ˆä¸€æ¬¡æ€§ï¼‰
- æ¨¡å‹è®­ç»ƒä¼˜åŒ–ï¼š160 äººæ—¶ï¼ˆä¸€æ¬¡æ€§ï¼‰
- ç”¨ä¾‹æ¨¡æ¿å»ºè®¾ï¼š80 äººæ—¶ï¼ˆä¸€æ¬¡æ€§ï¼‰

ç»´æŠ¤æˆæœ¬ï¼ˆå¹´ï¼‰ï¼š
- æ¡†æ¶å‡çº§ï¼š60 äººæ—¶/å¹´
- æ¨¡å‹ä¼˜åŒ–ï¼š40 äººæ—¶/å¹´  
- æ–° APK é€‚é…ï¼šæ¯ä¸ª 20 äººæ—¶

ä»¥ 10 ä¸ª APK ä¸ºä¾‹ï¼š
åˆæœŸï¼š200 + 160 + 80 = 440 äººæ—¶
å¹´åº¦ï¼š60 + 40 + 20*10 = 300 äººæ—¶/å¹´

ROI = (1260 + 1800 - 440 - 300) / (440 + 300) = 314%
```

### ğŸš€ **æ ¸å¿ƒä¼˜åŠ¿æ€»ç»“**

#### 1. **æŠ€æœ¯ä¼˜åŠ¿**
- **å¤šæ¨¡å¼è¯†åˆ«èåˆ**ï¼šXML + è§†è§‰è¯†åˆ« + ç™½ç›’è®¿é—®
- **æ™ºèƒ½é™çº§ç­–ç•¥**ï¼šè¯†åˆ«å¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°å¤‡ç”¨æ–¹æ¡ˆ
- **è®¾å¤‡æŠ½è±¡ç»Ÿä¸€**ï¼šå±è”½è®¾å¤‡å·®å¼‚ï¼Œç»Ÿä¸€æ“ä½œæ¥å£
- **AI é©±åŠ¨ç”Ÿæˆ**ï¼šä»è‡ªç„¶è¯­è¨€åˆ°å¯æ‰§è¡Œä»£ç çš„è‡ªåŠ¨è½¬æ¢

#### 2. **æ•ˆç‡ä¼˜åŠ¿**  
- **å¼€å‘æ•ˆç‡æå‡ 300%**ï¼šLLM ç”Ÿæˆ + æ¨¡æ¿åŒ–å¼€å‘
- **ç»´æŠ¤æˆæœ¬é™ä½ 80%**ï¼šæ¡†æ¶åŒ–ç®¡ç† + æ™ºèƒ½é€‚é…
- **æ‰§è¡Œé€Ÿåº¦æå‡ 200%**ï¼šå¹¶å‘æ‰§è¡Œ + æ™ºèƒ½è°ƒåº¦

#### 3. **è´¨é‡ä¼˜åŠ¿**
- **ç¨³å®šæ€§æå‡ 150%**ï¼šå¤šå±‚å¼‚å¸¸æ¢å¤ + æ™ºèƒ½é‡è¯•
- **è¦†ç›–ç‡æå‡ 100%**ï¼šæ”¯æŒå¤æ‚æ’­æ”¾åœºæ™¯æµ‹è¯•
- **å‡†ç¡®æ€§æå‡ 120%**ï¼šç™½ç›’éªŒè¯ + å¤šç»´æ–­è¨€

---

## ğŸ”® æœªæ¥è§„åˆ’

### ğŸ¯ **çŸ­æœŸç›®æ ‡ï¼ˆ3-6 ä¸ªæœˆï¼‰**

#### Phase 1: æ ¸å¿ƒæ¡†æ¶å»ºè®¾
```
âœ… å®ŒæˆåŸºç¡€æ¶æ„è®¾è®¡
ğŸ”„ å®ç°å¤šæ¨¡å¼å…ƒç´ è¯†åˆ«å¼•æ“
ğŸ”„ æ„å»ºè®¾å¤‡æŠ½è±¡å±‚
ğŸ“‹ å¼€å‘ç”¨ä¾‹æ‰§è¡Œå¼•æ“
ğŸ“‹ é›†æˆå¼‚å¸¸æ¢å¤æœºåˆ¶
```

#### Phase 2: AI èƒ½åŠ›é›†æˆ
```
ğŸ“‹ é›†æˆ LLM ç”¨ä¾‹ç”Ÿæˆ
ğŸ“‹ å®ç°æ™ºèƒ½å…ƒç´ åŒ¹é…
ğŸ“‹ å¼€å‘è‡ªé€‚åº”ç­‰å¾…ç­–ç•¥  
ğŸ“‹ æ„å»ºæ™ºèƒ½å¼‚å¸¸åˆ†æ
```

### ğŸš€ **ä¸­æœŸç›®æ ‡ï¼ˆ6-12 ä¸ªæœˆï¼‰**

#### Phase 3: ä¸“ä¸šåŒ–å®šåˆ¶
```
ğŸ“‹ é’ˆå¯¹å½±è§† APP çš„æ·±åº¦ä¼˜åŒ–
ğŸ“‹ æ’­æ”¾çŠ¶æ€ä¸“ç”¨è¯†åˆ«æ¨¡å‹
ğŸ“‹ DRM å†…å®¹æµ‹è¯•æ”¯æŒ
ğŸ“‹ å¤šåª’ä½“æ ¼å¼å…¼å®¹æ€§æµ‹è¯•
```

#### Phase 4: ä¼ä¸šçº§åŠŸèƒ½
```  
ğŸ“‹ äº‘ç«¯è®¾å¤‡ç®¡ç†å¹³å°
ğŸ“‹ åˆ†å¸ƒå¼æ‰§è¡Œè°ƒåº¦
ğŸ“‹ å®æ—¶ç›‘æ§é¢æ¿
ğŸ“‹ æ™ºèƒ½æŠ¥å‘Šåˆ†æ
```

### ğŸŒŸ **é•¿æœŸæ„¿æ™¯ï¼ˆ1-2 å¹´ï¼‰**

#### Phase 5: ç”Ÿæ€ç³»ç»Ÿå»ºè®¾
```
ğŸ“‹ å¼€æºç¤¾åŒºå»ºè®¾
ğŸ“‹ æ’ä»¶å¸‚åœºå¼€å‘
ğŸ“‹ ç¬¬ä¸‰æ–¹å·¥å…·é›†æˆ
ğŸ“‹ æ ‡å‡†åŒ–è§„èŒƒåˆ¶å®š
```

#### Phase 6: æ™ºèƒ½åŒ–è¿›åŒ–
```
ğŸ“‹ è‡ªè¿›åŒ–æµ‹è¯•æ¡†æ¶
ğŸ“‹ é¢„æµ‹æ€§æ•…éšœåˆ†æ
ğŸ“‹ è‡ªåŠ¨åŒ–æ€§èƒ½ä¼˜åŒ–
ğŸ“‹ é›¶ä»£ç æµ‹è¯•å¹³å°
```

### ğŸ¯ **æŠ€æœ¯æ¼”è¿›è·¯çº¿å›¾**

```
2024 Q1-Q2: åŸºç¡€æ¡†æ¶ + æ ¸å¿ƒåŠŸèƒ½
    â†“
2024 Q3-Q4: AI é›†æˆ + ä¸“ä¸šåŒ–å®šåˆ¶  
    â†“
2025 Q1-Q2: ä¼ä¸šçº§åŠŸèƒ½ + æ€§èƒ½ä¼˜åŒ–
    â†“
2025 Q3-Q4: ç”Ÿæ€å»ºè®¾ + ç¤¾åŒºè¿è¥
    â†“  
2026+: æ™ºèƒ½åŒ–è¿›åŒ– + è¡Œä¸šæ ‡å‡†
```

---

## ğŸ“– å‚è€ƒèµ„æ–™

### ğŸ“š **æŠ€æœ¯æ–‡æ¡£**
- [UIAutomator2 å®˜æ–¹æ–‡æ¡£](https://github.com/openatx/uiautomator2)
- [Omniparser é¡¹ç›®åœ°å€](https://github.com/microsoft/OmniParser)
- [YOLO å®˜æ–¹æ–‡æ¡£](https://github.com/ultralytics/ultralytics)
- [PaddleOCR ä½¿ç”¨æŒ‡å—](https://github.com/PaddlePaddle/PaddleOCR)

### ğŸ”— **è¡Œä¸šå®è·µ**
- [ç¾å›¢å¤–å–è‡ªåŠ¨åŒ–æµ‹è¯•å®è·µ](https://cloud.tencent.com/developer/article/2113563)
- [è´§æ‹‰æ‹‰å½•åˆ¶å›æ”¾æ¢ç´¢](https://juejin.cn/post/7306331307477794867)
- [çˆ±å¥‡è‰º DIFF è‡ªåŠ¨åŒ–æ–¹æ¡ˆ](https://juejin.cn/post/7001018350327463943)
- [åŸºäº AI çš„è‡ªåŠ¨åŒ–æµ‹è¯•è®¾è®¡](https://www.iqiyi.com/common/20190125/d5e434d41a41bdff.html)

### ğŸ› ï¸ **å·¥å…·é“¾å‚è€ƒ**
- [Android Debug Bridge (ADB)](https://developer.android.com/studio/command-line/adb)
- [Android æ·±åº¦é“¾æ¥å¼€å‘](https://developer.android.com/training/app-links/deep-linking)
- [MediaSessionManager API](https://developer.android.com/reference/android/media/session/MediaSessionManager)
- [AudioManager API](https://developer.android.com/reference/android/media/AudioManager)

### ğŸ¯ **ç›¸å…³é¡¹ç›®**
- [AppAgentX](https://github.com/Westlake-AGI-Lab/AppAgentX) - AI é©±åŠ¨çš„ç§»åŠ¨åº”ç”¨æµ‹è¯•
- [DroidRun](https://github.com/droidrun/droidrun) - Android è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶
- [Magma-UI](https://huggingface.co/spaces/microsoft/Magma-UI) - å¤šæ¨¡æ€ UI ç†è§£
- [Browser-Use](https://github.com/browser-use/workflow-use) - æµè§ˆå™¨è‡ªåŠ¨åŒ–å·¥å…·

---

## ğŸ“ **ç‰ˆæƒå£°æ˜**

```
Copyright (c) 2024 Only-Test Framework Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

<p align="center">
  <b>ğŸ¯ Only-Test: Write Once, Test Everywhere</b><br>
  <i>è®© AI é©±åŠ¨çš„è‡ªåŠ¨åŒ–æµ‹è¯•æˆä¸ºç°å®</i>
</p>