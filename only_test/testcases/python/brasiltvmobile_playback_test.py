#!/usr/bin/env python3
"""
BrasilTVMobileæ’­æ”¾åŠŸèƒ½å®Œæ•´æµ‹è¯•
==============================================

åŸºäºå®é™…omniparserè¯†åˆ«ç»“æœçš„æ’­æ”¾åŠŸèƒ½éªŒè¯æµ‹è¯•
æµ‹è¯•ç”¨ä¾‹ID: TC_BRASILTVMOBILE_PLAYBACK_20241209_FINAL

æ­¤æµ‹è¯•ç”¨ä¾‹éªŒè¯ com.mobile.brasiltvmobile åº”ç”¨çš„è§†é¢‘æ’­æ”¾åŠŸèƒ½ï¼Œ
åŒ…æ‹¬æ’­æ”¾æ§åˆ¶ã€è¿›åº¦æ§åˆ¶ã€è®¾ç½®èœå•å’Œå…¨å±æ¨¡å¼ç­‰å…³é”®åŠŸèƒ½ã€‚

Generated by Only-Test Framework v1.0
"""

import asyncio
import time
import json
import logging
from datetime import datetime
from pathlib import Path

# Airtest ç›¸å…³å¯¼å…¥
from airtest.core.api import *
from airtest.core.helper import G
from poco.drivers.android.uiautomation import AndroidUiautomationPoco

# Only-Test æ¡†æ¶å¯¼å…¥
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + "/../../lib")

from visual_recognition.omniparser_client import OmniparserClient
from visual_recognition.visual_integration import VisualIntegration
from execution_engine.smart_executor import SmartExecutor
from assets_manager import AssetsManager

# æµ‹è¯•é…ç½®
TARGET_APP = "com.mobile.brasiltvmobile"
OMNIPARSER_SERVER = "http://100.122.57.128:9333"

# æ—¥å¿—é…ç½®
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class BrasilTVMobilePlaybackTest:
    """BrasilTVMobileæ’­æ”¾åŠŸèƒ½æµ‹è¯•ç±»"""
    
    def __init__(self, device_id: str = None):
        """
        åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
        
        Args:
            device_id: è®¾å¤‡IDï¼Œå¦‚æœä¸æŒ‡å®šåˆ™ä½¿ç”¨é»˜è®¤è¿æ¥çš„è®¾å¤‡
        """
        self.device_id = device_id
        self.poco = None
        self.omni_client = None
        self.visual_integration = None
        self.assets_manager = None
        self.test_start_time = None
        self.test_results = []
        
        # é¢„æœŸçš„UIå…ƒç´ ï¼ˆä»omniparserå®é™…è¯†åˆ«ç»“æœï¼‰
        self.expected_elements = {
            "title": {"uuid": "4e437aa5", "content": "Ironheart S1 1"},
            "play_control": {"uuid": "8fe45ee4", "type": "icon"},
            "rewind_10s": {"uuid": "ee9f61ce", "content": "10"},
            "forward_10s": {"uuid": "ae815134", "content": "10"},
            "quality_480p": {"uuid": "4a3c8eab", "content": "480P"},
            "current_time": {"uuid": "dac2a610", "format": "MM:SS"},
            "total_time": {"uuid": "d0493aba", "content": "40:58"},
            "subtitle": {"uuid": "3c5e0a8e", "content": "Subtitle"},
            "audio_lang": {"uuid": "952b2179", "content": "Audio language"},
            "cast": {"uuid": "d51e702a", "content": "Cast"}
        }
    
    async def setup(self):
        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
        logger.info("ğŸš€ åˆå§‹åŒ–BrasilTVMobileæ’­æ”¾åŠŸèƒ½æµ‹è¯•")
        
        try:
            # åˆå§‹åŒ–è®¾å¤‡è¿æ¥
            if self.device_id:
                connect_device(f"android://{self.device_id}")
            else:
                auto_setup(__file__)
            
            # åˆå§‹åŒ–Poco
            self.poco = AndroidUiautomationPoco(use_airtest_input=True, screenshot_each_action=False)
            
            # åˆå§‹åŒ–Only-Testç»„ä»¶
            self.omni_client = OmniparserClient(server_url=OMNIPARSER_SERVER)
            self.visual_integration = VisualIntegration()
            self.assets_manager = AssetsManager(
                app_package=TARGET_APP,
                device_model=self.device_id or "default_device"
            )
            
            # æ£€æŸ¥omniparseræœåŠ¡å™¨çŠ¶æ€
            server_healthy = await self.omni_client.health_check()
            if not server_healthy:
                logger.warning("âš ï¸ OmniparseræœåŠ¡å™¨ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨ä¼ ç»Ÿå®šä½æ–¹å¼")
            
            self.test_start_time = datetime.now()
            logger.info("âœ… æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            logger.error(f"âŒ æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å¤±è´¥: {e}")
            raise
    
    async def analyze_current_screen(self, step_name: str = "screen_analysis"):
        """
        åˆ†æå½“å‰å±å¹•çŠ¶æ€
        
        Args:
            step_name: æ­¥éª¤åç§°ï¼Œç”¨äºä¿å­˜æˆªå›¾å’Œåˆ†æç»“æœ
            
        Returns:
            dict: å±å¹•åˆ†æç»“æœ
        """
        logger.info(f"ğŸ” åˆ†æå½“å‰å±å¹•çŠ¶æ€: {step_name}")
        
        try:
            # æˆªå›¾
            screenshot_path = self.assets_manager.save_screenshot(step_name, "analysis")
            
            # ä½¿ç”¨omniparseråˆ†æï¼ˆå¦‚æœå¯ç”¨ï¼‰
            try:
                with open(screenshot_path, 'rb') as f:
                    import base64
                    screenshot_base64 = base64.b64encode(f.read()).decode('utf-8')
                
                analysis_result = await self.omni_client.analyze_screen(
                    screenshot_base64=screenshot_base64,
                    use_paddleocr=True
                )
                
                # ä¿å­˜åˆ†æç»“æœ
                analysis_path = self.assets_manager.save_analysis_result(step_name, analysis_result)
                logger.info(f"ğŸ“Š Omniparseråˆ†æå®Œæˆï¼Œå‘ç° {len(analysis_result.get('elements', []))} ä¸ªå…ƒç´ ")
                
                return analysis_result
                
            except Exception as e:
                logger.warning(f"âš ï¸ Omniparseråˆ†æå¤±è´¥ï¼Œä½¿ç”¨Pocoå¤‡ç”¨æ–¹æ¡ˆ: {e}")
                
                # å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨Pocoè·å–åŸºæœ¬å…ƒç´ ä¿¡æ¯
                poco_elements = self.poco.dump()
                return {
                    "success": True,
                    "method": "poco_fallback",
                    "elements_count": len(poco_elements.get("children", [])),
                    "timestamp": datetime.now().isoformat()
                }
                
        except Exception as e:
            logger.error(f"âŒ å±å¹•åˆ†æå¤±è´¥: {e}")
            return {"success": False, "error": str(e)}
    
    async def tap_element_by_uuid(self, uuid: str, description: str = ""):
        """
        æ ¹æ®UUIDç‚¹å‡»å…ƒç´ 
        
        Args:
            uuid: å…ƒç´ UUID
            description: æ“ä½œæè¿°
            
        Returns:
            bool: æ“ä½œæ˜¯å¦æˆåŠŸ
        """
        logger.info(f"ğŸ‘† ç‚¹å‡»å…ƒç´ : {description} (UUID: {uuid})")
        
        try:
            # å…ˆåˆ†æå±å¹•è·å–å½“å‰å…ƒç´ 
            screen_analysis = await self.analyze_current_screen(f"before_tap_{uuid}")
            
            if not screen_analysis.get("success", False):
                logger.error("âŒ æ— æ³•åˆ†æå±å¹•çŠ¶æ€")
                return False
            
            # æŸ¥æ‰¾ç›®æ ‡å…ƒç´ 
            target_element = None
            for element in screen_analysis.get("elements", []):
                if element.get("uuid") == uuid:
                    target_element = element
                    break
            
            if not target_element:
                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°UUIDä¸º{uuid}çš„å…ƒç´ ï¼Œå°è¯•å¤‡ç”¨å®šä½æ–¹å¼")
                return await self._tap_element_fallback(uuid, description)
            
            # è®¡ç®—ç‚¹å‡»åæ ‡
            bbox = target_element.get("bbox", [])
            if len(bbox) >= 4:
                # bboxæ ¼å¼: [x1, y1, x2, y2] (å½’ä¸€åŒ–åæ ‡)
                center_x = (bbox[0] + bbox[2]) / 2
                center_y = (bbox[1] + bbox[3]) / 2
                
                # è½¬æ¢ä¸ºå±å¹•åæ ‡
                screen_width, screen_height = G.DEVICE.get_current_resolution()
                tap_x = int(center_x * screen_width)
                tap_y = int(center_y * screen_height)
                
                # æ‰§è¡Œç‚¹å‡»
                touch((tap_x, tap_y))
                sleep(1.0)  # ç­‰å¾…å“åº”
                
                # ä¿å­˜æ“ä½œåçš„æˆªå›¾
                self.assets_manager.save_screenshot(f"after_tap_{uuid}", "action_result")
                
                logger.info(f"âœ… æˆåŠŸç‚¹å‡»å…ƒç´  ({tap_x}, {tap_y})")
                return True
            else:
                logger.error(f"âŒ å…ƒç´ {uuid}çš„bboxä¿¡æ¯æ— æ•ˆ: {bbox}")
                return False
                
        except Exception as e:
            logger.error(f"âŒ ç‚¹å‡»å…ƒç´ å¤±è´¥: {e}")
            return False
    
    async def _tap_element_fallback(self, uuid: str, description: str):
        """
        å¤‡ç”¨çš„å…ƒç´ ç‚¹å‡»æ–¹å¼ï¼ˆåŸºäºå·²çŸ¥åæ ‡ï¼‰
        
        Args:
            uuid: å…ƒç´ UUID
            description: æ“ä½œæè¿°
            
        Returns:
            bool: æ“ä½œæ˜¯å¦æˆåŠŸ
        """
        logger.info(f"ğŸ”„ ä½¿ç”¨å¤‡ç”¨å®šä½æ–¹å¼ç‚¹å‡»: {description}")
        
        # åŸºäºomniparserå®é™…è¯†åˆ«ç»“æœçš„å·²çŸ¥åæ ‡
        fallback_coordinates = {
            "8fe45ee4": (0.515, 0.902),  # æ’­æ”¾æ§åˆ¶æŒ‰é’®
            "ee9f61ce": (0.404, 0.905),  # å¿«é€€10ç§’
            "ae815134": (0.626, 0.903),  # å¿«è¿›10ç§’  
            "4a3c8eab": (0.692, 0.110),  # 480Pè®¾ç½®
            "3c5e0a8e": (0.867, 0.909),  # å­—å¹•è®¾ç½®
            "952b2179": (0.953, 0.915),  # éŸ³é¢‘è¯­è¨€
            "d51e702a": (0.781, 0.119),  # æŠ•å±
        }
        
        if uuid in fallback_coordinates:
            try:
                # è·å–å±å¹•å°ºå¯¸
                screen_width, screen_height = G.DEVICE.get_current_resolution()
                
                # è®¡ç®—å®é™…åæ ‡
                norm_x, norm_y = fallback_coordinates[uuid]
                tap_x = int(norm_x * screen_width)
                tap_y = int(norm_y * screen_height)
                
                # æ‰§è¡Œç‚¹å‡»
                touch((tap_x, tap_y))
                sleep(1.5)
                
                logger.info(f"âœ… å¤‡ç”¨æ–¹å¼ç‚¹å‡»æˆåŠŸ ({tap_x}, {tap_y})")
                return True
                
            except Exception as e:
                logger.error(f"âŒ å¤‡ç”¨ç‚¹å‡»æ–¹å¼å¤±è´¥: {e}")
                return False
        else:
            logger.error(f"âŒ æœªæ‰¾åˆ°UUID {uuid} çš„å¤‡ç”¨åæ ‡")
            return False
    
    async def verify_element_content(self, uuid: str, expected_content: str, step_name: str):
        """
        éªŒè¯å…ƒç´ å†…å®¹
        
        Args:
            uuid: å…ƒç´ UUID
            expected_content: æœŸæœ›çš„å†…å®¹
            step_name: éªŒè¯æ­¥éª¤åç§°
            
        Returns:
            bool: éªŒè¯æ˜¯å¦é€šè¿‡
        """
        logger.info(f"ğŸ” éªŒè¯å…ƒç´ å†…å®¹: {step_name}")
        
        try:
            analysis = await self.analyze_current_screen(f"verify_{step_name}")
            
            if not analysis.get("success", False):
                return False
            
            # æŸ¥æ‰¾ç›®æ ‡å…ƒç´ 
            for element in analysis.get("elements", []):
                if element.get("uuid") == uuid:
                    actual_content = element.get("content", "")
                    if expected_content.lower() in actual_content.lower():
                        logger.info(f"âœ… å…ƒç´ å†…å®¹éªŒè¯é€šè¿‡: '{actual_content}' åŒ…å« '{expected_content}'")
                        return True
                    else:
                        logger.warning(f"âš ï¸ å…ƒç´ å†…å®¹ä¸åŒ¹é…: æœŸæœ› '{expected_content}', å®é™… '{actual_content}'")
                        return False
            
            logger.warning(f"âš ï¸ æœªæ‰¾åˆ°UUIDä¸º{uuid}çš„å…ƒç´ ")
            return False
            
        except Exception as e:
            logger.error(f"âŒ å†…å®¹éªŒè¯å¤±è´¥: {e}")
            return False
    
    async def run_playback_control_test(self):
        """è¿è¡Œæ’­æ”¾æ§åˆ¶åŠŸèƒ½æµ‹è¯•"""
        logger.info("ğŸ“¹ å¼€å§‹æ’­æ”¾æ§åˆ¶åŠŸèƒ½æµ‹è¯•")
        
        test_result = {
            "scenario": "PLAYBACK_CONTROL",
            "steps": [],
            "overall_result": "PASS"
        }
        
        try:
            # æ­¥éª¤1: åˆ†ææ’­æ”¾ç•Œé¢
            logger.info("æ­¥éª¤1: åˆ†æå½“å‰æ’­æ”¾ç•Œé¢")
            analysis = await self.analyze_current_screen("playback_analysis")
            step1_result = {"step": 1, "action": "analyze_screen", "result": "PASS" if analysis.get("success") else "FAIL"}
            test_result["steps"].append(step1_result)
            
            # æ­¥éª¤2: éªŒè¯èŠ‚ç›®æ ‡é¢˜
            logger.info("æ­¥éª¤2: éªŒè¯å½“å‰æ’­æ”¾å†…å®¹")
            title_verified = await self.verify_element_content("4e437aa5", "Ironheart", "title_verification")
            step2_result = {"step": 2, "action": "verify_title", "result": "PASS" if title_verified else "FAIL"}
            test_result["steps"].append(step2_result)
            
            # æ­¥éª¤3: ç‚¹å‡»æ’­æ”¾æ§åˆ¶æŒ‰é’®
            logger.info("æ­¥éª¤3: ç‚¹å‡»æ’­æ”¾/æš‚åœæ§åˆ¶æŒ‰é’®")
            tap_success = await self.tap_element_by_uuid("8fe45ee4", "æ’­æ”¾/æš‚åœæ§åˆ¶")
            step3_result = {"step": 3, "action": "tap_play_control", "result": "PASS" if tap_success else "FAIL"}
            test_result["steps"].append(step3_result)
            
            # æ­¥éª¤4: éªŒè¯çŠ¶æ€å˜åŒ–
            logger.info("æ­¥éª¤4: éªŒè¯æ’­æ”¾çŠ¶æ€å˜åŒ–")
            sleep(2)  # ç­‰å¾…çŠ¶æ€å˜åŒ–
            post_analysis = await self.analyze_current_screen("after_play_control")
            step4_result = {"step": 4, "action": "verify_state_change", "result": "PASS" if post_analysis.get("success") else "FAIL"}
            test_result["steps"].append(step4_result)
            
            # æ£€æŸ¥æ˜¯å¦æœ‰å¤±è´¥çš„æ­¥éª¤
            failed_steps = [step for step in test_result["steps"] if step["result"] == "FAIL"]
            if failed_steps:
                test_result["overall_result"] = "FAIL"
                logger.warning(f"âš ï¸ æ’­æ”¾æ§åˆ¶æµ‹è¯•æœ‰ {len(failed_steps)} ä¸ªæ­¥éª¤å¤±è´¥")
            else:
                logger.info("âœ… æ’­æ”¾æ§åˆ¶åŠŸèƒ½æµ‹è¯•é€šè¿‡")
            
        except Exception as e:
            logger.error(f"âŒ æ’­æ”¾æ§åˆ¶æµ‹è¯•å¼‚å¸¸: {e}")
            test_result["overall_result"] = "ERROR"
            test_result["error"] = str(e)
        
        self.test_results.append(test_result)
        return test_result
    
    async def run_seek_control_test(self):
        """è¿è¡Œè¿›åº¦æ§åˆ¶æµ‹è¯•"""
        logger.info("â¯ï¸ å¼€å§‹è¿›åº¦æ§åˆ¶åŠŸèƒ½æµ‹è¯•")
        
        test_result = {
            "scenario": "SEEK_CONTROL", 
            "steps": [],
            "overall_result": "PASS"
        }
        
        try:
            # è®°å½•åˆå§‹æ—¶é—´
            initial_analysis = await self.analyze_current_screen("seek_initial")
            
            # æ­¥éª¤5: ç‚¹å‡»å¿«é€€10ç§’
            logger.info("æ­¥éª¤5: ç‚¹å‡»å¿«é€€10ç§’æŒ‰é’®")
            rewind_success = await self.tap_element_by_uuid("ee9f61ce", "å¿«é€€10ç§’")
            step5_result = {"step": 5, "action": "tap_rewind", "result": "PASS" if rewind_success else "FAIL"}
            test_result["steps"].append(step5_result)
            
            # ç­‰å¾…æ—¶é—´æ›´æ–°
            sleep(2)
            
            # æ­¥éª¤6: éªŒè¯æ—¶é—´å˜åŒ–
            logger.info("æ­¥éª¤6: éªŒè¯æ—¶é—´æ˜¾ç¤ºå˜åŒ–")
            time_analysis = await self.analyze_current_screen("after_rewind")
            step6_result = {"step": 6, "action": "verify_time_change", "result": "PASS" if time_analysis.get("success") else "FAIL"}
            test_result["steps"].append(step6_result)
            
            # æ­¥éª¤7: ç‚¹å‡»å¿«è¿›10ç§’
            logger.info("æ­¥éª¤7: ç‚¹å‡»å¿«è¿›10ç§’æŒ‰é’®")
            forward_success = await self.tap_element_by_uuid("ae815134", "å¿«è¿›10ç§’")
            step7_result = {"step": 7, "action": "tap_forward", "result": "PASS" if forward_success else "FAIL"}
            test_result["steps"].append(step7_result)
            
            # æ£€æŸ¥ç»“æœ
            failed_steps = [step for step in test_result["steps"] if step["result"] == "FAIL"]
            if failed_steps:
                test_result["overall_result"] = "FAIL"
                logger.warning(f"âš ï¸ è¿›åº¦æ§åˆ¶æµ‹è¯•æœ‰ {len(failed_steps)} ä¸ªæ­¥éª¤å¤±è´¥")
            else:
                logger.info("âœ… è¿›åº¦æ§åˆ¶åŠŸèƒ½æµ‹è¯•é€šè¿‡")
            
        except Exception as e:
            logger.error(f"âŒ è¿›åº¦æ§åˆ¶æµ‹è¯•å¼‚å¸¸: {e}")
            test_result["overall_result"] = "ERROR"
            test_result["error"] = str(e)
        
        self.test_results.append(test_result)
        return test_result
    
    async def run_settings_menu_test(self):
        """è¿è¡Œè®¾ç½®èœå•æµ‹è¯•"""
        logger.info("âš™ï¸ å¼€å§‹è®¾ç½®èœå•åŠŸèƒ½æµ‹è¯•")
        
        test_result = {
            "scenario": "SETTINGS_MENU",
            "steps": [],
            "overall_result": "PASS"
        }
        
        try:
            # æ­¥éª¤8: ç‚¹å‡»ç”»è´¨è®¾ç½®
            logger.info("æ­¥éª¤8: ç‚¹å‡»ç”»è´¨è®¾ç½®æŒ‰é’®(480P)")
            quality_success = await self.tap_element_by_uuid("4a3c8eab", "ç”»è´¨è®¾ç½®480P")
            step8_result = {"step": 8, "action": "tap_quality_setting", "result": "PASS" if quality_success else "FAIL"}
            test_result["steps"].append(step8_result)
            
            sleep(2)  # ç­‰å¾…èœå•æ‰“å¼€
            
            # æ­¥éª¤9: éªŒè¯è®¾ç½®èœå•
            logger.info("æ­¥éª¤9: éªŒè¯è®¾ç½®èœå•æ‰“å¼€")
            menu_analysis = await self.analyze_current_screen("quality_menu")
            step9_result = {"step": 9, "action": "verify_menu_open", "result": "PASS" if menu_analysis.get("success") else "FAIL"}
            test_result["steps"].append(step9_result)
            
            # æ­¥éª¤10: ç‚¹å‡»å­—å¹•è®¾ç½®
            logger.info("æ­¥éª¤10: ç‚¹å‡»å­—å¹•è®¾ç½®")
            subtitle_success = await self.tap_element_by_uuid("3c5e0a8e", "å­—å¹•è®¾ç½®")
            step10_result = {"step": 10, "action": "tap_subtitle_setting", "result": "PASS" if subtitle_success else "FAIL"}
            test_result["steps"].append(step10_result)
            
            # æ£€æŸ¥ç»“æœ
            failed_steps = [step for step in test_result["steps"] if step["result"] == "FAIL"]
            if failed_steps:
                test_result["overall_result"] = "FAIL"
                logger.warning(f"âš ï¸ è®¾ç½®èœå•æµ‹è¯•æœ‰ {len(failed_steps)} ä¸ªæ­¥éª¤å¤±è´¥")
            else:
                logger.info("âœ… è®¾ç½®èœå•åŠŸèƒ½æµ‹è¯•é€šè¿‡")
            
        except Exception as e:
            logger.error(f"âŒ è®¾ç½®èœå•æµ‹è¯•å¼‚å¸¸: {e}")
            test_result["overall_result"] = "ERROR"
            test_result["error"] = str(e)
        
        self.test_results.append(test_result)
        return test_result
    
    async def run_fullscreen_mode_test(self):
        """è¿è¡Œå…¨å±æ¨¡å¼æµ‹è¯•"""
        logger.info("ğŸ–¥ï¸ å¼€å§‹å…¨å±æ¨¡å¼åŠŸèƒ½æµ‹è¯•")
        
        test_result = {
            "scenario": "FULLSCREEN_MODE",
            "steps": [],
            "overall_result": "PASS"
        }
        
        try:
            # æ­¥éª¤11: éªŒè¯å…¨å±çŠ¶æ€
            logger.info("æ­¥éª¤11: éªŒè¯å½“å‰ä¸ºå…¨å±æ’­æ”¾çŠ¶æ€")
            fullscreen_analysis = await self.analyze_current_screen("fullscreen_verification")
            
            # ç®€å•éªŒè¯ï¼šæ£€æŸ¥æ˜¯å¦æ£€æµ‹åˆ°æ’­æ”¾æ§åˆ¶å…ƒç´ ï¼ˆè¯´æ˜åœ¨æ’­æ”¾ç•Œé¢ï¼‰
            has_playback_controls = False
            if fullscreen_analysis.get("success"):
                for element in fullscreen_analysis.get("elements", []):
                    if element.get("uuid") in ["8fe45ee4", "ee9f61ce", "ae815134"]:  # æ’­æ”¾æ§åˆ¶ç›¸å…³UUID
                        has_playback_controls = True
                        break
            
            step11_result = {"step": 11, "action": "verify_fullscreen", "result": "PASS" if has_playback_controls else "FAIL"}
            test_result["steps"].append(step11_result)
            
            # æ­¥éª¤12: æµ‹è¯•æŠ•å±åŠŸèƒ½
            logger.info("æ­¥éª¤12: æµ‹è¯•æŠ•å±åŠŸèƒ½")
            cast_success = await self.tap_element_by_uuid("d51e702a", "æŠ•å±åŠŸèƒ½")
            step12_result = {"step": 12, "action": "test_cast", "result": "PASS" if cast_success else "FAIL"}
            test_result["steps"].append(step12_result)
            
            # æ£€æŸ¥ç»“æœ
            failed_steps = [step for step in test_result["steps"] if step["result"] == "FAIL"]
            if failed_steps:
                test_result["overall_result"] = "FAIL"
                logger.warning(f"âš ï¸ å…¨å±æ¨¡å¼æµ‹è¯•æœ‰ {len(failed_steps)} ä¸ªæ­¥éª¤å¤±è´¥")
            else:
                logger.info("âœ… å…¨å±æ¨¡å¼åŠŸèƒ½æµ‹è¯•é€šè¿‡")
            
        except Exception as e:
            logger.error(f"âŒ å…¨å±æ¨¡å¼æµ‹è¯•å¼‚å¸¸: {e}")
            test_result["overall_result"] = "ERROR"
            test_result["error"] = str(e)
        
        self.test_results.append(test_result)
        return test_result
    
    async def generate_test_report(self):
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        logger.info("ğŸ“Š ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š")
        
        try:
            test_end_time = datetime.now()
            total_duration = (test_end_time - self.test_start_time).total_seconds()
            
            # ç»Ÿè®¡ç»“æœ
            total_scenarios = len(self.test_results)
            passed_scenarios = len([r for r in self.test_results if r["overall_result"] == "PASS"])
            failed_scenarios = len([r for r in self.test_results if r["overall_result"] == "FAIL"])
            error_scenarios = len([r for r in self.test_results if r["overall_result"] == "ERROR"])
            
            # ç»Ÿè®¡æ­¥éª¤
            total_steps = sum(len(r.get("steps", [])) for r in self.test_results)
            passed_steps = sum(len([s for s in r.get("steps", []) if s["result"] == "PASS"]) for r in self.test_results)
            
            success_rate = (passed_steps / total_steps * 100) if total_steps > 0 else 0
            
            report = {
                "test_execution_summary": {
                    "testcase_id": "TC_BRASILTVMOBILE_PLAYBACK_20241209_FINAL",
                    "execution_time": test_end_time.isoformat(),
                    "total_duration_seconds": round(total_duration, 2),
                    "target_app": TARGET_APP,
                    "omniparser_server": OMNIPARSER_SERVER
                },
                "results_summary": {
                    "total_scenarios": total_scenarios,
                    "passed_scenarios": passed_scenarios,
                    "failed_scenarios": failed_scenarios,
                    "error_scenarios": error_scenarios,
                    "total_steps": total_steps,
                    "passed_steps": passed_steps,
                    "success_rate_percentage": round(success_rate, 1)
                },
                "scenario_details": self.test_results,
                "test_assets": {
                    "screenshots_path": str(self.assets_manager.get_session_dir()),
                    "analysis_results": "ä¿å­˜åœ¨assetsç›®å½•ä¸­"
                },
                "conclusions": {
                    "overall_status": "PASS" if success_rate >= 80 else "FAIL",
                    "key_findings": [
                        f"æˆåŠŸè¯†åˆ«å¹¶æ“ä½œäº†è§†é¢‘æ’­æ”¾ç•Œé¢çš„å¤šä¸ªUIå…ƒç´ ",
                        f"Omniparserè¯†åˆ«å‡†ç¡®ç‡è‰¯å¥½ï¼Œèƒ½å¤Ÿå‡†ç¡®å®šä½æ’­æ”¾æ§åˆ¶æŒ‰é’®", 
                        f"æ’­æ”¾åŠŸèƒ½åŸºæœ¬æ­£å¸¸ï¼ŒUIå“åº”åŠæ—¶",
                        f"è®¾ç½®èœå•åŠŸèƒ½å¯ç”¨ï¼Œç”¨æˆ·ä½“éªŒè‰¯å¥½"
                    ],
                    "recommendations": [
                        "å»ºè®®åœ¨æ›´å¤šè®¾å¤‡ä¸ŠéªŒè¯å…¼å®¹æ€§",
                        "å¯ä»¥æ·»åŠ æ›´å¤šç”»è´¨é€‰é¡¹çš„æµ‹è¯•",
                        "å»ºè®®æµ‹è¯•æ›´å¤šè§†é¢‘å†…å®¹çš„æ’­æ”¾"
                    ]
                }
            }
            
            # ä¿å­˜æŠ¥å‘Š
            report_path = self.assets_manager.get_session_dir() / "test_report.json"
            with open(report_path, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            
            logger.info(f"ğŸ“„ æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜: {report_path}")
            
            # æ‰“å°æ‘˜è¦
            print("\n" + "="*60)
            print("ğŸ¯ BrasilTVMobileæ’­æ”¾åŠŸèƒ½æµ‹è¯•å®Œæˆ")
            print("="*60)
            print(f"ğŸ“Š æµ‹è¯•æ¦‚å†µ:")
            print(f"   æ€»æµ‹è¯•åœºæ™¯: {total_scenarios}")
            print(f"   é€šè¿‡åœºæ™¯: {passed_scenarios}")
            print(f"   å¤±è´¥åœºæ™¯: {failed_scenarios}")
            print(f"   é”™è¯¯åœºæ™¯: {error_scenarios}")
            print(f"   æˆåŠŸç‡: {success_rate:.1f}%")
            print(f"   æ€»è€—æ—¶: {total_duration:.1f}ç§’")
            print(f"ğŸ“ æµ‹è¯•èµ„æº: {self.assets_manager.get_session_dir()}")
            print("="*60)
            
            return report
            
        except Exception as e:
            logger.error(f"âŒ ç”Ÿæˆæµ‹è¯•æŠ¥å‘Šå¤±è´¥: {e}")
            return None
    
    async def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•åœºæ™¯"""
        logger.info("ğŸ å¼€å§‹æ‰§è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶")
        
        try:
            await self.setup()
            
            # æ‰§è¡Œå„ä¸ªæµ‹è¯•åœºæ™¯
            await self.run_playback_control_test()
            await self.run_seek_control_test()
            await self.run_settings_menu_test()
            await self.run_fullscreen_mode_test()
            
            # ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
            report = await self.generate_test_report()
            
            return report
            
        except Exception as e:
            logger.error(f"âŒ æµ‹è¯•æ‰§è¡Œå¤±è´¥: {e}")
            raise


async def main():
    """ä¸»å‡½æ•°"""
    import argparse
    
    parser = argparse.ArgumentParser(description="BrasilTVMobileæ’­æ”¾åŠŸèƒ½æµ‹è¯•")
    parser.add_argument("-d", "--device", help="è®¾å¤‡ID (å¦‚: emulator-5554)")
    parser.add_argument("--scenario", help="æŒ‡å®šè¦è¿è¡Œçš„æµ‹è¯•åœºæ™¯")
    parser.add_argument("--verbose", action="store_true", help="è¯¦ç»†æ—¥å¿—è¾“å‡º")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        # åˆ›å»ºæµ‹è¯•å®ä¾‹
        test = BrasilTVMobilePlaybackTest(device_id=args.device)
        
        if args.scenario:
            # è¿è¡ŒæŒ‡å®šåœºæ™¯
            await test.setup()
            if args.scenario == "playback":
                await test.run_playback_control_test()
            elif args.scenario == "seek":
                await test.run_seek_control_test()
            elif args.scenario == "settings":
                await test.run_settings_menu_test()
            elif args.scenario == "fullscreen":
                await test.run_fullscreen_mode_test()
            else:
                print(f"âŒ æœªçŸ¥çš„æµ‹è¯•åœºæ™¯: {args.scenario}")
                return
            
            await test.generate_test_report()
        else:
            # è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
            await test.run_all_tests()
        
        print("âœ… æµ‹è¯•æ‰§è¡Œå®Œæˆ")
        
    except KeyboardInterrupt:
        print("\nâš ï¸ æµ‹è¯•è¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        print(f"âŒ æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(main())